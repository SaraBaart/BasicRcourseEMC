[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Basic R Course",
    "section": "",
    "text": "Hi, welcome to the Basic R Course manual."
  },
  {
    "objectID": "basic_plotting_intro.html",
    "href": "basic_plotting_intro.html",
    "title": "Basic plotting",
    "section": "",
    "text": "data(ToothGrowth)\nstr(ToothGrowth)\n\n'data.frame':   60 obs. of  3 variables:\n $ len : num  4.2 11.5 7.3 5.8 6.4 10 11.2 11.2 5.2 7 ...\n $ supp: Factor w/ 2 levels \"OJ\",\"VC\": 2 2 2 2 2 2 2 2 2 2 ...\n $ dose: num  0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ..."
  },
  {
    "objectID": "basic_plotting.html",
    "href": "basic_plotting.html",
    "title": "1  Basic plotting",
    "section": "",
    "text": "The plot function is the most basic function for plotting continuous data. If we use plot on one variable, the values of the variable will be plotted against their index, i.e., the order of the data within the object they’re stored:\n\nplot(ToothGrowth$len)\n\n\n\n\nWith two variables plot puts the first variable on the x-axis and the second variable on the y-axis (y versus x):\n\nplot(ToothGrowth$dose, ToothGrowth$len)\n\n\n\n\nMany parameters are available for customizing your plot. See ?par for an extensive list. We will just look at a couple here, like changing the axis labels:\n\nplot(ToothGrowth$dose, ToothGrowth$len, xlab = \"Dose\", ylab = \"Tooth Length\")\n\n\n\n\nWe can also add a title:\n\nplot(ToothGrowth$dose, ToothGrowth$len, xlab = \"Dose\", ylab = \"Tooth Length\", main = \"Guinea Pig Tooth Growth by Dosage\")\n\n\n\n\nand even change the colors and characters of specific points:\n\nplot(ToothGrowth$dose, \n     ToothGrowth$len, \n     xlab = \"Dose\", \n     ylab = \"Tooth Length\", \n     main = \"Guinea Pig Tooth Growth by Dosage\", \n     col = ToothGrowth$supp, \n     pch = as.numeric(ToothGrowth$supp))\n\n\n\n\nThe legend function adds a legend so we can easily identify which points represent which groups:\n\nplot(ToothGrowth$dose, ToothGrowth$len, xlab = \"Dose\", ylab = \"Tooth Length\", main = \"Guinea Pig Tooth Growth by Dosage\", col = ToothGrowth$supp, pch = as.numeric(ToothGrowth$supp))\n\nlegend(1.5, 15, c(\"OJ\", \"VC\"), col = 1:2, pch = 1:2)\n\n\n\n\nThe location of the legend can also be specified by stating a region of the plot e.g. “bottomright” to place it in the very bottom righthand corner of the plot.\nThe argument cex stands for “character expansion” and will enlarge the size of points:\n\nplot(ToothGrowth$dose, ToothGrowth$len, xlab = \"Dose\",\n     ylab = \"Tooth Length\", main = \"Guinea Pig Tooth Growth by Dosage\",\n     col = ToothGrowth$supp, pch = as.numeric(ToothGrowth$supp),\n     cex = 2)\n\nlegend(1.5, 15, c(\"OJ\", \"VC\"), col = 1:2, pch = as.numeric(ToothGrowth$supp), cex=2)\n\n\n\n\n\n\n\nTo create a plot using lines instead of points, we can actually still use plot, but we need to specify the type of plot we want, e.g.:\n\nplot(ToothGrowth$len, type = \"l\") # note type is the letter l for \"line\"\n\n\n\n\n\nplot(ToothGrowth$len, type = \"b\") # note type is the letter b for \"both\"\n\n\n\n\nWe can add additional lines by calling lines:\n\nplot(ToothGrowth$len, type = \"l\")\nlines(ToothGrowth$len + 2)\n\n\n\n\nThe line type, width, and color can be adjusted as follows:\n\nplot(ToothGrowth$len, type = \"l\")\nlines(ToothGrowth$len + 2, lty = 3, lwd = 3, col = \"darkgreen\")"
  },
  {
    "objectID": "basic_plotting.html#bar-charts-and-histograms",
    "href": "basic_plotting.html#bar-charts-and-histograms",
    "title": "1  Basic plotting",
    "section": "1.2 Bar Charts and Histograms",
    "text": "1.2 Bar Charts and Histograms\n\nBar Charts\nViewing categorical data in a scatterplot often doesn’t make sense. For example, if we want to see the number of guinea pigs who received each dosage, the following doesn’t provide this information in the most intuitive format:\n\nplot(ToothGrowth$dose)\n\n\n\n\n\ntable(ToothGrowth$dose)\n\n\n0.5   1   2 \n 20  20  20 \n\n\n\nbarplot(table(ToothGrowth$dose))\n\n\n\n\nWe can plot proportions instead of frequencies, as is often helpful (though not in this case):\n\nprops <- table(ToothGrowth$dose)/nrow(ToothGrowth)\nprops\n\n\n      0.5         1         2 \n0.3333333 0.3333333 0.3333333 \n\n\n\nbarplot(props)\n\n\n\n\nNote that the y-axis doesn’t quite extend to the height of the bars. The range of the y-axis is easily change in plots by adjusting the parameter ylim (similarly xlim for the x-axis):\n\nbarplot(props, ylim = c(0, .4))\n\n\n\n\nYet again, there are many parameters available for customizing the plot. Let’s try changing the width and colors of the bars:\n\nbarplot(props, ylim = c(0, .4), width = .2, col = c(\"blue\", \"white\", \"red\"))\n\n\n\n\nAnd we can plot the bars horizontally, if preferable:\n\nbarplot(props, xlim = c(0, .4),\n  width = .2, col = c(\"blue\", \"white\", \"red\"),\n  horiz = TRUE)\n\n\n\n\nNote that we adjusted the range of the x-axis now instead of the y-axis.\n\n\nHistograms\nA bar chart is slightly different from a histogram. We use bar charts to plot frequencies (or proportions) of values present in categories. Continuous data don’t have categories, so to make a similar plot we have to create “categories”. They are often called bins or cells and are created by delining ranges in which the frequencies are calculated. Thankfully, R will do this, and plot the histogram, when we call the function hist:\n\nhist(ToothGrowth$len)\n\n\n\n\nNote that in a histogram the sides of the cells touch, whereas they do not in a bar chart. We can also plot the proportions, now called “density”, by changing a single parameter:\n\nhist(ToothGrowth$len, freq = FALSE)\n\n\n\n\nIn the next graph we plot the histogram with a different bin width by specifying where to make the breakpoints between the bars:\n\nhist(ToothGrowth$len, freq = FALSE, breaks = seq(0, 35, 2))\n\n\n\n\nNote how the granularity of the plot changes with the width of the bin. We can also change the breaks by delining the number of cells to use:\n\nhist(ToothGrowth$len, freq = FALSE, breaks = 25)\n\n\n\n\nThe same parameters that change the axes and labels are applicable here:\n\nhist(ToothGrowth$len, freq = FALSE, breaks = seq(0, 35, 2),\n  main = \"Histogram of Tooth Growth\", xlab = \"Tooth Length\",\n  ylim = c(0, .07), col = \"orange\")"
  },
  {
    "objectID": "basic_plotting.html#boxplots",
    "href": "basic_plotting.html#boxplots",
    "title": "1  Basic plotting",
    "section": "1.3 Boxplots",
    "text": "1.3 Boxplots\nA boxplot is another graph we use to view the distribution of a continuous variable. It displays the specified quantiles of the data in the following way:\n\nboxplot(ToothGrowth$len)\n\n\n\n\nA single boxplot is nice for visualizing the distribution of one variable, but plotting several side by side allows for a simultaneous comparison of distributions. Here we will use the formula notation. The format y ~ x, where y is a numeric vector and x is a factor, tells the boxplot function that we want to separate the continuous y values into as many boxplots as there are levels of the factor x.\n\nboxplot(ToothGrowth$len~ToothGrowth$supp)\n\n\n\n\nJust like in the bar chart, we can plot the boxes horizontally and change the colors, labels and axes:\n\nboxplot(ToothGrowth$len~ToothGrowth$supp,\n  col = c(\"darkgreen\", \"purple\"),\n  ylab = \"Supplement Type\", xlab = \"Tooth Length\",\n  ylim = c(0, 40), horizontal = TRUE)\n\n\n\n\nThe settings of the parameters of a plot, including the margins, can be specified by calling par() before creating a plot. One nice setting we’ll introduce here is how to put multiple plots into one graphics device:\n\npar(mfrow = c(1, 2))\n  boxplot(ToothGrowth$len~ToothGrowth$supp, main = \"Boxplot\",\n  xlab = \"Supplement Type\")\n  \nhist(ToothGrowth$len, main = \"Histogram\", xlab = \"Tooth Length\")\n\n\n\n\nThe settings will stay fixed until we close the device (e.g. by calling dev.off()) or reset par (e.g. par(mfrow = c(1, 1))). It is highly recommended to get familiar with the help page for par to control graphing parameters to create custom graphs. Another helpful function is axis, which allows the specification of custom axis labels (e.g. where to put them and at what angle). See ?axis for more information."
  },
  {
    "objectID": "basic_plotting.html#saving-plots",
    "href": "basic_plotting.html#saving-plots",
    "title": "1  Basic plotting",
    "section": "1.4 Saving Plots",
    "text": "1.4 Saving Plots\nUp until now we have been creating graphs in a single graphics window that gets overwritten every time we create new plots. If we want to save the images created, we can use “Export” in RStudio to specify what type of file we want to write, its size, location, and name.\nAlternatively we can use functions such as png, pdf, and jpeg. Since we can save our code and not our mouse clicks, the use of these functions avoids any confusion about how an image was written, allows for quick simple changes, and provides a convenient way to reproduce multiple, similar plots. For example:\n\n# note: run getwd() to see the working directory -\n# that is the directory to which files will be written\npdf(\"plot1.pdf\", width = 6, height = 9)\nboxplot(ToothGrowth$len~ToothGrowth$supp,\n  col = c(\"darkgreen\", \"purple\"),\n  xlab = \"Supplement Type\", ylab = \"Tooth Length\",\n  ylim = c(0, 40), horizontal = TRUE)\ndev.off()\n\npdf(\"plot2.pdf\", width = 4, height = 8)\nboxplot(ToothGrowth$len~ToothGrowth$supp,\n  col = c(\"darkgreen\", \"purple\"),\n  xlab = \"Supplement Type\", ylab = \"Tooth Length\",\n  ylim = c(0, 40), horizontal = TRUE)\ndev.off()\n\nNote that you have to call dev.off() to finish writing the image to the file. If more than one device is open, the return of that function will display a number larger than 1.\nThe units for the width and height arguments of pdf are in inches (7 by 7), but the default for e.g. png is pixels (there is an argument units to change it to in, cm, or mm):\n\npng(\"plot1.png\", units = \"in\", res = 300,\n  width = 6, height = 9)\n\nboxplot(ToothGrowth$len~ToothGrowth$supp,\n  col = c(\"darkgreen\", \"purple\"),\n  xlab = \"Supplement Type\", ylab = \"Tooth Length\",\n  ylim = c(0, 40), horizontal = TRUE)\n\ndev.off()"
  },
  {
    "objectID": "basic_plotting_practicals_questions.html",
    "href": "basic_plotting_practicals_questions.html",
    "title": "2  Basic Plotting: Questions",
    "section": "",
    "text": "Question 1\n\n\nDisplay the built-in dataset called BOD by running BOD.\n\n\n\n\nQuestion 2\n\n\nWhat is the data structure of BOD? What are the dimensions?\n\n\n\n\nQuestion 3\n\n\nWhat are the names of BOD? Use a function other than str.\n\n\n\n\nQuestion 3\n\n\nMake a line graph of demand versus time, where the line is a deep pink dot-dashed line [Hint: run ?par and look for the parameter lty to see the line types]. Add a blue dashed line of 1.1 times the demand and give it a thickness of 2 using the line width parameter lwd. Make sure both lines are entirely visible by adjusting the range of y using the parameter ylim in the original plot.\n\n\n\nUse R to do the following exercises on the chickwts data.\n\nQuestion 4\n\n\nDisplay the built-in chickwts data.\n\n\n\n\nQuestion 5\n\n\nWhat are the names of chickwts? Use a function other than str\n\n\n\n\nQuestion 6\n\n\nWhat are the levels of feed?\n\n\n\n\nQuestion 7\n\n\nMake the following plots in one 2 x 2 image: - A bar chart of the feed types, each bar a different color. - A bar chart of the proportions of feed types, each bar a different color. - A boxplot of the weights by feed type, each box a different color. - A horizontal boxplot of the weights by feed type, each box a different color.\n\n\n\nUse R to do the following exercises on the Puromycin data.\n\nQuestion 8\n\n\nDisplay the built-in Puromycin data.\n\n\n\n\nQuestion 9\n\n\nMake a scatterplot of the rate versus the concentration. Describe the relationship.\n\n\n\n\nQuestion 10\n\n\nMake a scatterplot of the rate versus the log of the concentration. Describe the relationship.\n\n\n\n\nQuestion 11\n\n\nMake a scatterplot of the rate versus the log of the concentration and color the points by treatment group (state). Describe what you see.\n\n\n\n\nQuestion 12\n\n\nMake a scatterplot of the rate versus the log of the concentration, color the points by treatment group (state), label the x-axis “Concentration” and the y-axis “Rate”, and label the plot “Puromycin”.\n\n\n\n\nQuestion 13\n\n\nAdd a legend to the above plot indicating what the points represent.\n\n\n\n\nQuestion 14\n\n\nMake a boxplot of the treated versus untreated rates. Using the function pdf, save the image to a file with a width and height of 7 inches.\n\n\n\n\nQuestion 15\n\n\nMake a histogram of the frequency of concentrations. What is the width of the bins?\n\n\n\n\nQuestion 16\n\n\nMake a histogram of the frequency of concentrations with a bin width of 0.10. How is this different from the histogram above?\n\n\n\n\nQuestion 17\n\n\nPlot the histograms side by side in the same graphic window and make sure they have the same range on the y-axis. Does this make it easier to answer the question of how the two histograms differ?"
  },
  {
    "objectID": "basic_plotting_practicals_answers.html",
    "href": "basic_plotting_practicals_answers.html",
    "title": "3  Basic Plotting: Answers",
    "section": "",
    "text": "Use R to do the following exercises on the BOD data\n\nQuestion 1Answer\n\n\nDisplay the built-in dataset called BOD by running BOD.\n\n\n\nBOD\n\n  Time demand\n1    1    8.3\n2    2   10.3\n3    3   19.0\n4    4   16.0\n5    5   15.6\n6    7   19.8\n\n\n\n\n\n\nQuestion 2Answer\n\n\nWhat is the data structure of BOD? What are the dimensions?\n\n\n\nstr(BOD)\n\n'data.frame':   6 obs. of  2 variables:\n $ Time  : num  1 2 3 4 5 7\n $ demand: num  8.3 10.3 19 16 15.6 19.8\n - attr(*, \"reference\")= chr \"A1.4, p. 270\"\n\ndim(BOD)\n\n[1] 6 2\n\n\n\n\n\n\nQuestion 3Answer\n\n\nWhat are the names of BOD? Use a function other than str.\n\n\n\nnames(BOD)\n\n[1] \"Time\"   \"demand\"\n\n\n\n\n\n\nQuestion 3Answer\n\n\nMake a line graph of demand versus time, where the line is a deep pink dot-dashed line [Hint: run ?par and look for the parameter lty to see the line types]. Add a blue dashed line of 1.1 times the demand and give it a thickness of 2 using the line width parameter lwd. Make sure both lines are entirely visible by adjusting the range of y using the parameter ylim in the original plot.\n\n\n\nplot(BOD$Time, BOD$demand, type = \"l\", lty = 4,\n  col = \"pink\", ylim = c(0, 25))\nlines(BOD$Time, 1.1 * BOD$demand, lwd = 2, col = \"blue\")\n\n\n\n\n\n\n\nUse R to do the following exercises on the chickwts data.\n\nQuestion 4Answer\n\n\nDisplay the built-in chickwts data.\n\n\n\nchickwts\n\n   weight      feed\n1     179 horsebean\n2     160 horsebean\n3     136 horsebean\n4     227 horsebean\n5     217 horsebean\n6     168 horsebean\n7     108 horsebean\n8     124 horsebean\n9     143 horsebean\n10    140 horsebean\n11    309   linseed\n12    229   linseed\n13    181   linseed\n14    141   linseed\n15    260   linseed\n16    203   linseed\n17    148   linseed\n18    169   linseed\n19    213   linseed\n20    257   linseed\n21    244   linseed\n22    271   linseed\n23    243   soybean\n24    230   soybean\n25    248   soybean\n26    327   soybean\n27    329   soybean\n28    250   soybean\n29    193   soybean\n30    271   soybean\n31    316   soybean\n32    267   soybean\n33    199   soybean\n34    171   soybean\n35    158   soybean\n36    248   soybean\n37    423 sunflower\n38    340 sunflower\n39    392 sunflower\n40    339 sunflower\n41    341 sunflower\n42    226 sunflower\n43    320 sunflower\n44    295 sunflower\n45    334 sunflower\n46    322 sunflower\n47    297 sunflower\n48    318 sunflower\n49    325  meatmeal\n50    257  meatmeal\n51    303  meatmeal\n52    315  meatmeal\n53    380  meatmeal\n54    153  meatmeal\n55    263  meatmeal\n56    242  meatmeal\n57    206  meatmeal\n58    344  meatmeal\n59    258  meatmeal\n60    368    casein\n61    390    casein\n62    379    casein\n63    260    casein\n64    404    casein\n65    318    casein\n66    352    casein\n67    359    casein\n68    216    casein\n69    222    casein\n70    283    casein\n71    332    casein\n\n\n\n\n\n\nQuestion 5Answer\n\n\nWhat are the names of chickwts? Use a function other than str\n\n\n\nnames(chickwts)\n\n[1] \"weight\" \"feed\"  \n\n\n\n\n\n\nQuestion 6Answer\n\n\nWhat are the levels of feed?\n\n\n\nlevels(chickwts$feed)\n\n[1] \"casein\"    \"horsebean\" \"linseed\"   \"meatmeal\"  \"soybean\"   \"sunflower\"\n\n\n\n\n\n\nQuestion 7Answer\n\n\nMake the following plots in one 2 x 2 image: - A bar chart of the feed types, each bar a different color. - A bar chart of the proportions of feed types, each bar a different color. - A boxplot of the weights by feed type, each box a different color. - A horizontal boxplot of the weights by feed type, each box a different color.\n\n\n\npar(mfrow = c(2, 2))\n\nbarplot(table(chickwts$feed),\n  col = c(\"red\", \"orange\", \"yellow\",\n  \"green\", \"blue\", \"purple\"))\n\nbarplot(table(chickwts$feed)/length(chickwts$feed),\n  col = c(\"red\", \"orange\", \"yellow\",\n  \"green\", \"blue\", \"purple\"))\n\nboxplot(chickwts$weight~chickwts$feed,\n  col = c(\"red\", \"orange\", \"yellow\",\n  \"green\", \"blue\", \"purple\"))\n\nboxplot(chickwts$weight~chickwts$feed,\n  col = c(\"red\", \"orange\", \"yellow\",\n  \"green\", \"blue\", \"purple\"),\n  horizontal = TRUE)\n\n\n\n\n\n\n\nUse R to do the following exercises on the Puromycin data.\n\nQuestion 8Answer\n\n\nDisplay the built-in Puromycin data.\n\n\n\nPuromycin\n\n   conc rate     state\n1  0.02   76   treated\n2  0.02   47   treated\n3  0.06   97   treated\n4  0.06  107   treated\n5  0.11  123   treated\n6  0.11  139   treated\n7  0.22  159   treated\n8  0.22  152   treated\n9  0.56  191   treated\n10 0.56  201   treated\n11 1.10  207   treated\n12 1.10  200   treated\n13 0.02   67 untreated\n14 0.02   51 untreated\n15 0.06   84 untreated\n16 0.06   86 untreated\n17 0.11   98 untreated\n18 0.11  115 untreated\n19 0.22  131 untreated\n20 0.22  124 untreated\n21 0.56  144 untreated\n22 0.56  158 untreated\n23 1.10  160 untreated\n\n\n\n\n\n\nQuestion 9Answer\n\n\nMake a scatterplot of the rate versus the concentration. Describe the relationship.\n\n\n\nplot(Puromycin$conc, Puromycin$rate)\n\n\n\n\nThe rate increases faster at lower concentrations than at higher concentrations.\n\n\n\n\nQuestion 10Answer\n\n\nMake a scatterplot of the rate versus the log of the concentration. Describe the relationship.\n\n\n\nplot(log(Puromycin$conc), Puromycin$rate)\n\n\n\n\nThe two variables have a linear relationship\n\n\n\n\nQuestion 11Answer\n\n\nMake a scatterplot of the rate versus the log of the concentration and color the points by treatment group (state). Describe what you see.\n\n\n\nplot(log(Puromycin$conc), Puromycin$rate, col = Puromycin$state)\n\n\n\n\nIt appears that the the treated group has higher rates than the untreated group, on average. (Note that default colors are black for the first level and red for the second level).\n\n\n\n\nQuestion 12Answer\n\n\nMake a scatterplot of the rate versus the log of the concentration, color the points by treatment group (state), label the x-axis “Concentration” and the y-axis “Rate”, and label the plot “Puromycin”.\n\n\n\nplot(log(Puromycin$conc), Puromycin$rate, col = Puromycin$state,\n  xlab = \"Concentration\", ylab = \"Rate\", main = \"Puromycin\")\n\n\n\n\n\n\n\n\nQuestion 13Answer\n\n\nAdd a legend to the above plot indicating what the points represent.\n\n\n\nplot(log(Puromycin$conc), Puromycin$rate, col = Puromycin$state,\n  xlab = \"Concentration\", ylab = \"Rate\", main = \"Puromycin\")\n\nlegend(\"topleft\",c(\"Treated\", \"Untreated\"), col = 1:2, pch = 1)\n\n\n\n\n\n\n\n\nQuestion 14Answer\n\n\nMake a boxplot of the treated versus untreated rates. Using the function pdf, save the image to a file with a width and height of 7 inches.\n\n\n\npdf(\"puromycin.pdf\",width = 7, height = 7)\nboxplot(Puromycin$rate~Puromycin$state)\ndev.off()\n\n\n\n\n\nQuestion 15Answer\n\n\nMake a histogram of the frequency of concentrations. What is the width of the bins?\n\n\n\nhist(Puromycin$conc)\n\n\n\n\nThe bin width is 0.20.\n\n\n\n\nQuestion 16Answer\n\n\nMake a histogram of the frequency of concentrations with a bin width of 0.10. How is this different from the histogram above?\n\n\n\nhist(Puromycin$conc, breaks = seq(0, 1.2, .10))\n\n\n\n\nThe bins are narrower, so we see in finer detail the distribution of the concentrations.\n\n\n\n\nQuestion 17Answer\n\n\nPlot the histograms side by side in the same graphic window and make sure they have the same range on the y-axis. Does this make it easier to answer the question of how the two histograms differ?\n\n\n\npar(mfrow = c(1, 2))\nhist(Puromycin$conc, ylim = c(0, 12))\nhist(Puromycin$conc, breaks = seq(0, 1.2, .10), ylim = c(0, 12))\n\n\n\n\nIn some situations it may be of use to view plots simultaneously. In this case, on the right we see clearly that more values are between 0 and 0.10 than 0.10 and 0.20 whereas the plot on the left does not display this information. In the histogram on the right we see that no concentrations fall between 0.30 and 0.50, whereas this is not apparent in the histogram on the left."
  },
  {
    "objectID": "ggplot2_intro.html",
    "href": "ggplot2_intro.html",
    "title": "ggplot2",
    "section": "",
    "text": "The basic plotting functions of R are nice to quickly visualize data, however, the strength of R is that it has many packages with extra functionality created by others that you can use. ggplot2 is one of those packages, created by Hadley Wickham. ggplot2 allows you to build more sophisticated plots in R using a “Grammar of Graphics” (therefore GGplot).\nIf ggplot2 is not yet available for you we need to install and load the ggplot2 library like so.\nggplot2 is a very extensive package, so it is impossible to show all the possibilities during this course. If you would like to experiment further, the ggplot manual at http://ggplot2.tidyverse.org/reference/index.html is the place to go. A large variety of functionalities are listed there, including example plots."
  },
  {
    "objectID": "ggplot2_intro.html#grammar-of-graphics",
    "href": "ggplot2_intro.html#grammar-of-graphics",
    "title": "ggplot2",
    "section": "Grammar of graphics",
    "text": "Grammar of graphics\nThe grammar of graphics consists of a number of “layers”, which generate a ggplot when correctly put together. These five basic layers will be discussed here:\n\nData\nAesthetics\nGeometries\nFacets\nScales\nThemes"
  },
  {
    "objectID": "ggplot2.html#data",
    "href": "ggplot2.html#data",
    "title": "4  Data visualization using ggplot2",
    "section": "4.1 Data",
    "text": "4.1 Data\nThe basis of each plot is the data. To plot data with ggplot the data needs to be of the class “data.frame”. The structure of your data.frame is important when you want to plot it with ggplot. Each variable you want to use has to be in a separate column in your data.frame. Take for example the “Indometh” data set which comes with R.\n\n?Indometh\n\nThe “Indometh”” data set describes the pharmacokinetics of indomethacin after intravenous injection of indomethacin in six subjects. The data.frame has three columns one containing the subject number, one containing the time of sampling in hours, and one containing the indomethacin concentration ug/ml. This data set is easily plotted with ggplot because it is a data.frame and there is a good separation of variables in the columns.\n\n\n  Subject time conc\n1       1 0.25 1.50\n2       1 0.50 0.94\n3       1 0.75 0.78\n4       1 1.00 0.48\n5       1 1.25 0.37\n6       1 2.00 0.19\n\n\nAn example of a badly formatted data set for visualization with ggplot is a data set of monthly deaths from lung diseases in the UK:\n\n?ldeaths\n\nThis data set contains three separate data sets for female, male and both male and female deaths (ldeaths, fdeaths, and mdeaths). The columns contain values per month and the rows indicate the year. (also they are not data.frames)\n\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n1974 3035 2552 2704 2554 2014 1655 1721 1524 1596 2074 2199 2512\n1975 2933 2889 2938 2497 1870 1726 1607 1545 1396 1787 2076 2837\n1976 2787 3891 3179 2011 1636 1580 1489 1300 1356 1653 2013 2823\n1977 3102 2294 2385 2444 1748 1554 1498 1361 1346 1564 1640 2293\n1978 2815 3137 2679 1969 1870 1633 1529 1366 1357 1570 1535 2491\n1979 3084 2605 2573 2143 1693 1504 1461 1354 1333 1492 1781 1915\n\n\nSince there are two separate data sets, there is no column indicating the sex. There is also no column indicating the year and no column indicating the month. This means that we cannot use these variables in ggplot to visualize, for instance, the difference between the number of deaths in men and women in a certain year. We can use some more advanced R data reshaping to get these data sets in the right shape.\n\n\n  Deaths Year Month    Sex\n1    901 1974   Jan female\n2    689 1974   Feb female\n3    827 1974   Mar female\n4    677 1974   Apr female\n5    522 1974   May female\n6    406 1974   Jun female\n\n\n\nggplot(data, aes(x=Month, y=Deaths, color=Sex)) + geom_point()\n\n\n\n\n\n\n\n\nHowever, it is much more easy to keep in mind that any variable that you want to use as a part of your ggplot should get its own column when you are designing your data set (in Excel). With the data in the right class and the right format we can easily call the ggplot function, and add a scatter plot layer to it."
  },
  {
    "objectID": "ggplot2.html#aesthetics",
    "href": "ggplot2.html#aesthetics",
    "title": "4  Data visualization using ggplot2",
    "section": "4.2 Aesthetics",
    "text": "4.2 Aesthetics\nAfter figuring out what data to plot it is necessary to indicate how to plot it. Aesthetics are used to indicate how to plot what. As we saw in the plot of the ldeaths data we start with indicating what data.frame to plot and use aes() to indicate what to plot on the x axis, the y axis and what to use as color. We do not have to indicate what to plot where and which color to give to which category. We simply map a column of our data.frame to an aesthetic. Depending on the geom we use there are a number of aesthetics that can be mapped to a variable:\n\nx\ny\ncolor\nfill\nsize\nalpha\nlinetype\nlabels\nshape\ngroup\n\nAesthetics can also be specified per geom layer. This allows plotting multiple geom layers with different aesthetics. However, when using one data source and one geom layer this will result in exactly the same plot.\n\nggplot(data) + geom_point(aes(x=Month, y=Deaths, color=Sex))\n\nWe can also use plotting parameters without mapping them to a variable to change all dots in the geom_point. This can only be done in the geom itself.\n\nggplot(data, aes(x=Month, y=Deaths, color=Sex)) + geom_point(size=3)"
  },
  {
    "objectID": "ggplot2.html#geometries",
    "href": "ggplot2.html#geometries",
    "title": "4  Data visualization using ggplot2",
    "section": "4.3 Geometries",
    "text": "4.3 Geometries\nFor the previous ggplots we have used the geom_point function which generates a scatter plot layer that can be added to the ggplot. “point” is one of the many geometry layers available in the ggplot library. There are over thirty different geoms in ggplot which can be found at http://docs.ggplot2.org/. We will have a look at the plot types that we have already encountered using the basic R plotting functions and replace them with their ggplot counterparts.\n\nScatter plots\nJust like with other objects in R a ggplot object can be saved to a variable using “<-”. This makes it possible to store the basic plot in a variable and add different geoms to it. Geometries are added to a plot using “+”.\n\n#Basic graphics:\nplot(ToothGrowth$len)\n\n\n\n\n\n\n\n\n\np <- ggplot(ToothGrowth)\np + geom_point(aes(x=as.numeric(rownames(ToothGrowth)), y=len), size=2)\n\n\n\n\n\n\n\n\nWe now map the numeric row names of ToothGrowth to the x aesthetic, however, we could also create a new column called index in the data.frame.\n\nToothGrowth$index <- as.numeric(rownames(ToothGrowth))\n\nWhen we change the data of the ggplot object we saved in variable p we need to recreate the ggplot object with the new data set.\n\np <- ggplot(ToothGrowth)\n\n\n\nLine graphs\n\n#Basic graphics:\nplot(ToothGrowth$len, type = \"l\")\n\n\n\n\n\n\n\np + geom_line(aes(x=index, y=len))\n\n\n\n\n\n\n\n\n\n\nBar charts\n\n#Basic graphics:\nbarplot(table(ToothGrowth$dose))\n\n\n\n\n\n\n\np + geom_bar(aes(x=dose))\n\n\n\n\n\n\n\n\nBecause dose is a continuous variable, ggplot creates a x axis with a continuous scale, which is why there is an empty spot for the 1.5 dose. If we want to use a continuous value as a categorical value we can change it into a factor on the fly in the geom function:\n\np + geom_bar(aes(x=as.factor(dose)))\n\n\n\n\n\n\n\n\n\n\nHistograms\n\n#Basic graphics:\nhist(ToothGrowth$len,breaks = 50)\n\n\n\n\n\n\n\np + geom_histogram(aes(x=len), binwidth = 0.5)\n\n\n\n\n\n\n\n\n\n\nBox plots\n\n#Basic graphics:\nboxplot(ToothGrowth$len~ToothGrowth$supp)\n\n\n\n\n\n\n\n\n\np + geom_boxplot(aes(x=supp,y=len))\n\n\n\n\n\n\n\n\nIf we want whiskers in our plot we can add an error bar geom\n\np + geom_errorbar(aes(x=supp, ymin=..., ymax=...),width=0.5)\n\n\n\n\n\n\n\n\n\n\nHowever, as you can see, this geom requires ymin and ymax as aesthetics and does not calculate the values by itself. We could calculate the min and max values for tooth length grouped by supplement, but we will use a trick using ggplot’s box plot statistics function. (if you want to know more, please read more about these “stat” functions online)\nFirst, we add the error bars with the “stat_boxplot” function, and then add the box plots on top of them.\n\np + stat_boxplot(aes(x=supp,y=len), geom=\"errorbar\", width=0.5) + \n    geom_boxplot(aes(x=supp,y=len))\n\n\n\n\n\n\n\n\nAs we can see the aesthetics of both geoms have to be defined separately in this plot. To reduce typing we could also write the ggplot as follows.\n\np <- ggplot(ToothGrowth, aes(x=supp,y=len)) \np + stat_boxplot(geom=\"errorbar\", width=0.5) + geom_boxplot()\n\nWhen the aesthetics are specified in the base ggplot object it is not necessary to specify them in the added layers.\n\n\nHeatmaps\nOne popular way of displaying large grids of data is using a heatmap. The tile geom generates a tile at each provided x and y value and uses the fill aesthetic to fill the tiles according to another variable. The border color of the tiles are can be changed by using the color aesthetic.\n\np <- ggplot(ToothGrowth)\n\np + geom_tile(aes(x = supp, y = as.factor(dose), fill = len), color=\"black\")\n\n\n\n\n\n\n\n\nThere are dedicated packages for plotting heatmaps, which also perform horizontal and vertical clustering of the tiles. These are, however, out of the scope of this course, but it should be easy to find them online."
  },
  {
    "objectID": "ggplot2.html#facets",
    "href": "ggplot2.html#facets",
    "title": "4  Data visualization using ggplot2",
    "section": "4.4 Facets",
    "text": "4.4 Facets\nApart from using aesthetics to map variables to, ggplot has another feature which can help visualizing data called “facets”. We have added multiple plots to the viewing window before, using “par(mfrow=c(…,…))”. However, after specifying how many plots should be printed in the plot viewer we have to call the plot function multiple times to populate the viewer.\nIf we want to compare the effect of orange juice versus vitamin C depending on the dose we can plot three box plots next to each other.\n\npar(mfrow = c(1, 3))\n\nlow <- ToothGrowth[which(ToothGrowth$dose==0.5),]\nmed <- ToothGrowth[which(ToothGrowth$dose==1),]\nhigh <- ToothGrowth[which(ToothGrowth$dose==2),]\n\nboxplot(low$len~low$supp, main = \"Low dose\", xlab = \"Supplement Type\")\nboxplot(med$len~med$supp, main = \"Medium dose\", xlab = \"Supplement Type\")\nboxplot(high$len~high$supp, main = \"High dose\", xlab = \"Supplement Type\")\n\n\n\n\n\n\n\n\nHowever, using ggplot we can simply map the dose column to a ggplot facet grid. The mapping of variables is not done via a aes(), but in formula form. Variables on the right indicate the columns in the grid and variables on the left indicate the rows of the grid. A “.” can be used if we want to use only one variable for faceting. This will also preserve the scales, making it more easy to compare the three plots. For fun, let’s add the actual data points in an additional geom on top of the box plot.\n\nggplot(ToothGrowth, aes(x=supp,y=len)) + \n    stat_boxplot(geom=\"errorbar\", width=0.5) + \n    geom_boxplot() + geom_point(color=\"red\") + \n    facet_grid(. ~ as.factor(dose))\n\n\n\n\n\n\n\n\nWe can do the same with two variables in a grid.\n\nggplot(ToothGrowth, aes(x=len)) + \n    geom_histogram(bins = 5) + \n    facet_grid(dose ~ as.factor(supp))"
  },
  {
    "objectID": "ggplot2.html#scales",
    "href": "ggplot2.html#scales",
    "title": "4  Data visualization using ggplot2",
    "section": "4.5 Scales",
    "text": "4.5 Scales\nWhen mapping a variable to one of the aesthetics of a ggplot, ggplot uses the default scales. It is however possible to adjust the scales of the plot and their color using the scales functions. The scales that are generally used the most are those for the x, y, color and fill of the plot. The type of function to adjust the scale of one of the aesthetics depends on the aesthetic and the type of variable (continuous or discrete). Some of the possible scale adjustments, such as limits, transformation, breaks, labels, and color, are exemplified by the plot below.\n\nggplot(ToothGrowth, aes(x=index, y=as.factor(dose), color=len)) + \n    geom_point() + \n    scale_x_continuous(limits=c(1,100), trans = \"log2\", \n        breaks=c(2,4,8,16,32,64), \n        label=c(\"two\",\"four\",\"eight\",\"sixteen\",\"thirtytwo\",\"sixtyfour\")) + \n    scale_y_discrete(label=c(\"low\",\"medium\",\"high\")) + \n    scale_color_gradient2(limits=c(0,40), low = \"green\", mid = \"black\", high = \"red\", \n        midpoint = 20)\n\n\n\n\n\n\n\n\nHave a look at the scales chapter at http://ggplot2.tidyverse.org/reference/ to explore the other possibilities!"
  },
  {
    "objectID": "ggplot2.html#themes",
    "href": "ggplot2.html#themes",
    "title": "4  Data visualization using ggplot2",
    "section": "4.6 Themes",
    "text": "4.6 Themes\nUntil now we have simply mapped a variable from our data set to an aesthetics parameter, potentially change the scales, and let ggplot handle the styling of the graph. However, ggplot has many options to customize the style of your plot using themes. There are several standard themes that we can use, however it is possible to create our own style from scratch.\nThe standard themes available in the ggplot package are:\n\ntheme_gray\ntheme_bw\ntheme_linedraw\ntheme_light\ntheme_dark\ntheme_minimal\ntheme_classic\ntheme_void\n\nTo add a standard theme we simply add the theme to the ggplot like we would with a geom.\n\np <- ggplot(ToothGrowth)\np + geom_point(aes(x = index, y = len, color = supp, size = dose)) + theme_light()\n\n\n\n\n\n\n\n\nCustom themes can be made from scratch using the “theme()” function. To have a look at all customization parameters visit http://ggplot2.tidyverse.org/reference/theme.html. Labels can be edited by adding “labs()” to the plot.\n\np <- ggplot(ToothGrowth)\np + geom_point(aes(x = index, y = len, color = supp, size = dose)) + \n    theme(text = element_text(family = \"serif\", colour = \"#6f898e\"), \n      line = element_line(color = \"#163f47\"), \n      rect = element_rect(fill = \"#163f47\", color = \"#163f47\"),\n        axis.text.x = element_text(color=\"black\"), \n        axis.text.y = element_text(color=\"white\"), \n      axis.ticks = element_line(color = \"#6f898e\"), \n      axis.line = element_line(color = \"#163f47\", linetype = 1),\n        legend.background = element_blank(), \n        legend.key = element_blank(), \n        panel.background = element_rect(fill = \"#215c68\", colour = \"#163f47\"), \n        panel.border = element_blank(), \n      panel.grid = element_line(color = \"#163f47\"), \n      panel.grid.major = element_line(color = \"#163f47\"), \n      panel.grid.minor = element_line(color = \"#163f47\"), \n      plot.background = element_rect(fill = NULL, colour = NA, linetype = 0)\n    ) + \n    labs(title=\"Toothgrowth\", \n        subtitle = \"Orange juice or Vitamin C?\", x=\"Index\", y=\"Toothlength\", \n        size=\"Dose\", color=\"Supplement\") +\n    scale_color_manual(label=c(\"Orange juice\",\"Vitamin C\"), \n        values = c(\"VC\"=\"green\",\"OJ\"=\"orange\"))"
  },
  {
    "objectID": "ggplot2.html#saving-ggplots",
    "href": "ggplot2.html#saving-ggplots",
    "title": "4  Data visualization using ggplot2",
    "section": "4.7 Saving ggplots",
    "text": "4.7 Saving ggplots\nWe can save out plots by using the ggsave() function. ggsave takes two argument, the first argument being the ggplot and the second being the location where the file should be saved. If we do not specify the complete path, it will save the plot in our current working directory (getwd()). The type of the file depends on the file extension we use. Possible file extensions are “eps”, “ps”, “tex” (pictex), “pdf”, “jpeg”, “tiff”, “png”, “bmp”, “svg” or “wmf” (windows only).\n\np <- ggplot(ToothGrowth)\n\nmyplot <- p + geom_point(aes(x = index, y = len, color = supp, size = dose))\n\nggsave(\"my_plot.pdf\",myplot)"
  },
  {
    "objectID": "ggplot2.html#ggplot2-extensions",
    "href": "ggplot2.html#ggplot2-extensions",
    "title": "4  Data visualization using ggplot2",
    "section": "4.8 ggplot2 extensions",
    "text": "4.8 ggplot2 extensions\nBasic ggplot functions are enough to create a rich variety of plots. However, depending on the field of research, specific plots are popular to visualize specific types of data. Sometimes these plots cannot be made directly from “basic” ggplot. Since ggplot is an opensource package, several people have extended it fulfill the custom needs of users. Many of these ggplot extension packages can be found online with a quick google. The ggplot2 extensions gallery shows some nice examples of add-ons https://exts.ggplot2.tidyverse.org/gallery/. Below are a handful of examples, which we will not explain in detail, but should serve as a source of inspiration.\n\n\n\nggridgeshttps://cran.r-project.org/web/packages/ggridges/\n\n\n\n\n\nplotROC https://github.com/sachsmc/plotROC\n\n\n\n\n\nsurvminer https://rpkgs.datanovia.com/survminer/index.html"
  },
  {
    "objectID": "ggplot2_practicals_questions.html",
    "href": "ggplot2_practicals_questions.html",
    "title": "5  ggplot: Questions",
    "section": "",
    "text": "# if needed install.packages(\"ggplot2\")\nlibrary(ggplot2)\ndata(\"diamonds\")\n\n\nQuestion 1\n\n\nExplore the data set using dim(), str() and help(), which variables are continuous, which variables are discrete? Is this data set ready for plotting with ggplot?\n\n\n\n\nQuestion 2\n\n\nUse ggplot to plot a scatterplot of the relationship between the diamonds’ carat a\n\n\n\n\nQuestion 3\n\n\nMake all dots darkblue and set the alpha value to 0.1\n\n\n\n\nQuestion 4\n\n\nVisualize the influence of the color of a diamond on its price by mapping the diamond color to the color aesthetic\n\n\n\n\nQuestion 5\n\n\nUse a ggplot barplot to visualize diamond clarity depending on color, map diamond color to x and diamond clarity to fill\n\n\n\n\nQuestion 6\n\n\nCreate a boxplot of the carat of a diamond based on its clarity and add whiskers using stat_boxplot\n\n\n\n\nQuestion 7\n\n\nAdd a geom_point layer to the previous plot mapping the diamonds price to the color\n\n\n\n\nQuestion 8\n\n\nCreate a histogram of the price of the diamonds and separate the histograms into facets using diamond color, choose a good binwith or number of bins\n\n\n\n\nQuestion 9\n\n\nCreate a grid of facets of the same histogram by comparing both color and cut\n\n\n\n\nQuestion 10\n\n\nUse aggregate(diamonds, by = list(cut = diamonds$cut, color = diamonds$color), mean) to calculate the mean of all variables by cut and color. Create a heatmap of the mean prices by cut and color using geom_tile\n\n\n\n\nQuestion 11\n\n\nChange the title of the heatmap to “Average prices”\n\n\n\n\nQuestion 12\n\n\nChange the gradient of the fill scale using ‘scale_fill_gradient2’. Have it go from darkblue to white to darkred, set the midpoint to 4500\n\n\n\n\nQuestion 13\n\n\nChoose and add a theme to the heatmap, or create a theme yourself using the options listed at http://ggplot2.tidyverse.org/reference/theme.html"
  },
  {
    "objectID": "ggplot2_practicals_answers.html",
    "href": "ggplot2_practicals_answers.html",
    "title": "6  ggplot: Answers",
    "section": "",
    "text": "Question 1Answer 1\n\n\nExplore the data set using dim(), str() and help(), which variables are continuous, which variables are discrete? Is this data set ready for plotting with ggplot?\n\n\nExplore the data set using dim(), str() and help(), which variables are continuous, which variables are discrete? Is this data set ready for plotting with ggplot?\n\ndim(diamonds)\nstr(diamonds)\nhelp(diamonds)\n\n\n\n\n\nQuestion 2Answer 2\n\n\nUse ggplot to plot a scatterplot of the relationship between the diamonds’ carat and their price\n\n\nUse ggplot to plot a scatterplot of the relationship between the diamonds’ carat and their price\n\nggplot() + geom_point(data=diamonds, aes(x=carat, y=price))\n\n#or\n\nggplot(diamonds) + geom_point(aes(x=carat, y=price))\n\n#or\n\nggplot(diamonds, aes(x=carat, y=price)) + geom_point()\n\nCut, color, and clarity are factors, and therefore discrete. The others are numeric continuous variables.\n\n\n\n\nQuestion 3Answer 3\n\n\nMake all dots darkblue and set the alpha value to 0.1\n\n\nMake all dots darkblue and set the alpha value to 0.1\n\nggplot(diamonds, aes(x=carat, y=price)) + geom_point(color=\"darkblue\", alpha=0.1)\n\n\n\n\n\nQuestion 4Answer 4\n\n\nVisualize the influence of the color of a diamond on its price by mapping the diamond color to the color aesthetic\n\n\nVisualize the influence of the color of a diamond on its price by mapping the diamond color to the color aesthetic\n\n#The color of the dots will be overwritten if we specify it statically  \n#in the geom_point function itself\nggplot(diamonds, aes(x=carat, y=price, color=color)) + geom_point(alpha=0.1)\n\n\n\n\n\nQuestion 5Answer 5\n\n\nUse a ggplot barplot to visualize diamond clarity depending on color, map diamond color to x and diamond clarity to fill\n\n\nUse a ggplot barplot to visualize diamond clarity depending on color, map diamond color to x and diamond clarity to fill\n\nggplot(diamonds, aes(x=color, fill=clarity)) + geom_bar()\n\n\n\n\n\nQuestion 6Answer 6\n\n\nCreate a boxplot of the carat of a diamond based on its clarity and add whiskers using stat_boxplot\n\n\nCreate a boxplot of the carat of a diamond based on its clarity and add whiskers using stat_boxplot\n\nggplot(diamonds, aes(x=clarity, y=carat)) + \n    stat_boxplot(geom=\"errorbar\", width=0.5) + \n    geom_boxplot()\n\n\n\n\n\nQuestion 7Answer 7\n\n\nAdd a geom_point layer to the previous plot mapping the diamonds price to the color\n\n\nAdd a geom_point layer to the previous plot mapping the diamonds price to the color\n\nggplot(diamonds, aes(x=clarity, y=carat)) + \n    stat_boxplot(geom=\"errorbar\", width=0.5) + \n    geom_boxplot() + \n    geom_point(aes(color=price))\n\n\n\n\n\nQuestion 8Answer 8\n\n\nCreate a histogram of the price of the diamonds and separate the histograms into facets using diamond color, choose a good binwith or number of bins\n\n\nCreate a histogram of the price of the diamonds and separate the histograms into facets using diamond color, choose a good binwith or number of bins\n\nggplot(diamonds, aes(x=price)) + \n    geom_histogram(binwidth = 100) + \n    facet_grid(color ~ .)\n\n\n\n\n\nQuestion 9Answer 9\n\n\nCreate a grid of facets of the same histogram by comparing both color and cut\n\n\nCreate a grid of facets of the same histogram by comparing both color and cut\n\nggplot(diamonds, aes(x=price)) + \n    geom_histogram(binwidth = 100) + \n    facet_grid(color ~ cut)\n\n\n\n\n\nQuestion 10Answer 10\n\n\nUse aggregate(diamonds, by = list(cut = diamonds$cut, color = diamonds$color), mean) to calculate the mean of all variables by cut and color. Create a heatmap of the mean prices by cut and color using geom_tile\n\n\nUse aggregate(diamonds, by = list(cut = diamonds$cut, color = diamonds$color), mean) to calculate the mean of all variables by cut and color. Create a heatmap of the mean prices by cut and color using geom_tile\n\n#Aggregate uses a function (in this case mean) to aggregate all variables \n#in a given data.frame by a list of variables given in \"by\"\nmean.price <- aggregate(diamonds, by = list(cut = diamonds$cut, color = diamonds$color), mean)\n\nggplot(mean.price, aes(x=cut, y=color, fill=price)) + \n    geom_tile()\n\n\n\n\n\nQuestion 11Answer 11\n\n\nChange the title of the heatmap to “Average prices”\n\n\nChange the title of the heatmap to “Average prices”\n\nggplot(mean.price, aes(x=cut, y=color, fill=price)) + \n    geom_tile() + \n    labs(title=\"Average prices\")\n\n\n\n\n\nQuestion 12Answer 12\n\n\nChange the gradient of the fill scale using ‘scale_fill_gradient2’. Have it go from darkblue to white to darkred, set the midpoint to 4500\n\n\nChange the gradient of the fill scale using ‘scale_fill_gradient2’. Have it go from darkblue to white to darkred, set the midpoint to 4500\n\nggplot(mean.price, aes(x=cut, y=color, fill=price)) + \n    geom_tile() + \n    labs(title=\"Average prices\") + \n    scale_fill_gradient2(low=\"darkblue\", mid=\"white\", high=\"darkred\", midpoint = 4500)\n\n\n\n\n\nQuestion 13Answer 13\n\n\nChoose and add a theme to the heatmap, or create a theme yourself using the options listed at http://ggplot2.tidyverse.org/reference/theme.html\n\n\nChoose and add a theme to the heatmap, or create a theme yourself using the options listed at http://ggplot2.tidyverse.org/reference/theme.html\n\nggplot(mean.price, aes(x=cut, y=color, fill=price)) + \n    geom_tile() + \n    labs(title=\"Average prices\") + \n    scale_fill_gradient2(low=\"darkblue\", mid=\"white\", high=\"darkred\", midpoint = 4500) + \n    theme_minimal()"
  },
  {
    "objectID": "functions_intro.html",
    "href": "functions_intro.html",
    "title": "Functions 1",
    "section": "",
    "text": "http://stat.ethz.ch/R-manual/R-patched/library/base/html/00Index.html\nhttp://cran.r-project.org/web/packages/available_packages_by_name.html\nhttp://www.bioconductor.org/packages/release/bioc/\nFunctions are expressed as:\nfunction.name(), e.g., t.test() or, an operator, e.g., +\nEasily obtain functions from other R users using install.packages():\ninstall.packages(\"packageName\", lib = \"/directory/to/my custom R library\", repos = \"http://cran.xl-mirror.nl\")\nThe package name must be quoted when installing. Besides installing the package on your PC, you need to load it into your R session before you can use it:\nlibrary(\"packageName\") ## quotes are optional when loading a package"
  },
  {
    "objectID": "functions_types.html",
    "href": "functions_types.html",
    "title": "7  Types of available functions",
    "section": "",
    "text": "Relational Operators\nUsing these functions it is possible to compare variables to other variables or to specific values.\n\n#Previously we defined x as 10 and y as 3\nx < y   #Smaller than\n\n[1] FALSE\n\nx > y   #Larger than\n\n[1] TRUE\n\nx <= y  #Smaller or equal to\n\n[1] FALSE\n\nx >= y  #Larger or equal to\n\n[1] TRUE\n\nx == y  #Equal to (use two '=')\n\n[1] FALSE\n\nx != y  #Not equal to (! means 'not')\n\n[1] TRUE\n\n\n\n\nLogical Operators\nR has logical operators (or Boolean operators) corresponding to “and” and “or”. They’re used to combine two logical expressions together to form a single compound logical expression. Another logical operator corresponding to “not” is used to negate a logical expression.\nThese are written in R as:\n\n&&  # \"And\"   for logical scalars (single values)\n||  # \"Or\"    for logical scalars\n!   # \"Not\"   for logical scalars or vectors\n&   # \"And\"   for logical vectors (multiple values)\n|   # \"Or\"    for logical vectors\n\nThese operate on logical (TRUE or FALSE) expressions and return TRUE or FALSE or TRUE/FALSE vectors.\nThe distinction between && and &, and between || and | is that the former is for single values and the latter for multiple values.\nLogical Operations on Scalar Logical Expressions\n&& returns TRUE if both of the expressions are TRUE and it returns FALSE otherwise:\n\nTRUE && TRUE\n\n[1] TRUE\n\nTRUE && FALSE\n\n[1] FALSE\n\n\n|| returns TRUE if one or both of the expressions are TRUE and it returns FALSE otherwise:\n\nFALSE || TRUE\n\n[1] TRUE\n\nFALSE || FALSE\n\n[1] FALSE\n\n\nAs a practical example, if we want to test whether a variable x lies between two numbers, say 60 and 70, we type:\n\nx <- 75\nx > 60 && x < 70\n\n[1] FALSE\n\n\nand to test whether it lies outside the range 60 to 70, we type:\n\nx < 60 || x > 70\n\n[1] TRUE\n\n\nHere’s an example of using && in an if() statement:\n\nx <- 3\ny <- 5\n\nif(x < 10 && y < 10) {\n  print(\"Both less than 10\")\n} else {\n  print(\"Not both less than 10\")\n}\n\n[1] \"Both less than 10\"\n\n\nThe negation operator, !, returns “the opposite” of a logical expression:\n\n!TRUE\n\n[1] FALSE\n\n\n\n!FALSE\n\n[1] TRUE\n\n\n\n!(5 < 6)\n\n[1] FALSE\n\n\nPay attention to the operator precedence for &&, ||, and !. It can be found by typing: ?Syntax but parentheses can be used to control the order of operations.\nIf we try to apply && or || to vectors, R only applies it to their first elements, and you get a warning:\n\nc(TRUE, FALSE, TRUE) && c(TRUE, TRUE, FALSE)\n\nWarning in c(TRUE, FALSE, TRUE) && c(TRUE, TRUE, FALSE): 'length(x) = 3 > 1' in\ncoercion to 'logical(1)'\n\nWarning in c(TRUE, FALSE, TRUE) && c(TRUE, TRUE, FALSE): 'length(x) = 3 > 1' in\ncoercion to 'logical(1)'\n\n\n[1] TRUE\n\n\nLogical Operations on Logical Vectors\nTo apply the operations “and” and “or” element-wise on two logical vectors, use & and |. For example:\n\nc(TRUE, FALSE, TRUE) & c(TRUE, TRUE, FALSE)\n\n[1]  TRUE FALSE FALSE\n\n\n& and | are useful in ifelse() statements. (Recall that ifelse() operates element-wise on vectors). For example, consider the systolic and diastolic blood pressure readings:\n\nsystolic <- c(110, 119, 111, 113, 128)\ndiastolic <- c(70, 74, 88, 74, 83)\n\nA blood pressure is classified as normal if the systolic level is less than 120 and the diastolic level is less than 80:\n\nclassification <- ifelse(systolic < 120 & diastolic < 80, yes = \"Normal\", no = \"Abnormal\")\nclassification\n\n[1] \"Normal\"   \"Normal\"   \"Abnormal\" \"Normal\"   \"Abnormal\"\n\n\nIn the next example, we use & in square brackets [ ] to extract rows from a data frame:\n\nbpData <- data.frame(\n  name = c(\"Joe\", \"Katy\", \"Bill\", \"Kim\", \"Mark\"),\n  systolic = c(110, 119, 111, 113, 128),\n  diastolic = c(70, 74, 88, 74, 83)\n)\n\nbpData\n\n  name systolic diastolic\n1  Joe      110        70\n2 Katy      119        74\n3 Bill      111        88\n4  Kim      113        74\n5 Mark      128        83\n\nbpData[bpData$systolic < 120 & bpData$diastolic < 80, ]\n\n  name systolic diastolic\n1  Joe      110        70\n2 Katy      119        74\n4  Kim      113        74\n\n\n\n\nBuilt-in Named Functions\nR has an extensive set of built-in functions, a few of which are listed below:\nPrint structure of an object:\n\nstr()\n\nPrint class of an object:\n\nclass()\n\nFirst six elements/rows:\n\nhead()\n\nLast six elements/rows:\n\ntail()\n\nList all objects and functions that you currently made:\n\nls()\n\nGenerate a sequence of values:\n\nseq(from=1, to=10, by=2)\n\n[1] 1 3 5 7 9\n\n\nRun the entire contents of a script:\n\nsource(\"myScript.R\")\n\nFor a (very long) list of all named functions available in base-R have a look at this website:\nhttps://stat.ethz.ch/R-manual/R-patched/library/base/html/00Index.html"
  },
  {
    "objectID": "functions_arguments.html",
    "href": "functions_arguments.html",
    "title": "8  Function arguments",
    "section": "",
    "text": "Optional Arguments and Default Values\nThe specification digits = 0 in the output from args(round) tells us that digits has a default value of 0. This means that it’s an optional argument and if no value is passed for that argument, rounding is done to 0 decimal places (i.e. to the nearest integer).\n\n\nPositional Matching and Named Argument Matching\nWhen we type round(4.679, 2) R knows, by positional matching, that the first value, 4.679, is the value to be rounded and the second one, 2, is the number of decimal places to round to.\nWe can also specify values for the arguments by name. For example:\n\nround(x = 4.679, digits = 2)\n\n[1] 4.68\n\n\nWhen named argument matching is used, as above, the order of the arguments is irrelevant. For example, we get the same result by typing:\n\nround(digits = 2, x = 4.679)\n\n[1] 4.68\n\n\nThe two types of argument specification (positional and named argument matching) can be mixed in the same function call:\n\nround(4.679, digits=2)\n\n[1] 4.68\n\n\nAlthough it may be confusing, it is also possible to specify the first argument in the second position, by using named argument matching for the second argument like so:\n\nround(digits=2, 4.679)\n\n[1] 4.68\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor readability of your code it is advisable to name most of the arguments when calling a function"
  },
  {
    "objectID": "functions_custom.html",
    "href": "functions_custom.html",
    "title": "9  Creating your own functions",
    "section": "",
    "text": "The general form is:\n\nmyFun <- function(arg1, arg2) {\n  ## Here you type expressions that use the arguments\n}\n\nEach line inside the function is an object assignment, a function call, a subsetting, a conditional statement, an if/else statement, a for loop, etc. - basically anything you have now learned how to do in R that you want the function to do!\nTo have the function output something, you must return something (either the value of the last command is returned or you can use return()).\nIf you have multiple objects to return, you have to put them in an object container, like a list, vector, array or data.frame. It is not possible to return multiple individual objects like this:\nreturn(x,y)\nbut it is possible to return them in a vector or list like this:\nreturn(c(x,y))\nreturn(list(x,y)\nHere are a few examples of functions with no default arguments; note the different outputs:\n\ndo1 <- function(x, y){\n  z <- x + y\n  x\n  z\n}\n\ndo1(x = 1, y = 3)\n\n[1] 4\n\n\nNote that x is not returned. Only the last expression is returned.\n\ndo2 <- function(x, y){\n  z <- x + y \n  return(x)\n  z\n}\n\ndo2(x = 1, y = 3)\n\n[1] 1\n\n\nNote that z is not returned, if a return statement is encountered in the function anything after that statement is not executed.\n\ndo3 <- function(x, y){ \n  z <- x + y \n  return(list(x, z))\n}\n\ndo3(x = 1, y = 3)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n\nx and z are returned in a list\nHere is an example of a function with default arguments that returns a vector:\n\ndo4 <- function(x, y = 2){ \n  z1 <- x + y\n  z2 <- x * y \n  return(c(z1, z2))\n} \n\ndo4(x = 1) ## uses y = 2\n\n[1] 3 2\n\ndo4(x = 1, y = 3) ## overwrites default value of y\n\n[1] 4 3\n\n\nYou can create functions with a variable number of arguments using .... For example, here’s a function that returns the mean of all the values in an arbitrary number of vectors:\n\nmeanOfAll <- function(...) {\n  x <- mean(c(...))\n  return(x)\n}\n\nThe command\n\nusSales <- c(123,456,789)\neuropeSales <- c(100,1000,10000,100000)\notherSales <- c(50,100,150,200,250,300,350)\n\nmeanOfAll(usSales, europeSales, otherSales)\n\n[1] 8133.429\n\n\ncombines the three vectors and take the mean of all the data."
  },
  {
    "objectID": "functions_conditional.html",
    "href": "functions_conditional.html",
    "title": "10  Conditional execution using if and else",
    "section": "",
    "text": "Nested if() Statements\nIn addition, if() statements can be nested. The form for nested if() statements is\n\nif(condition1) {\n  if(condition2) {\n    statement1 \n  } else {\n    statement2\n  }\n}\n\nThe else always refers to the most recent if(), but to keep our code readable, we use tab indentation for every level of nesting in our nested if-else statements.\nApart form nesting if() statements it is also possible to string multiple if statements together like so:\n\nwhatAnimalSound <- function(animal){\n  if(animal == \"cat\") {\n    return(\"Meow!\")\n  } else if (animal == \"frog\") {\n    return(\"Ribbit!\")\n  } else if (animal == \"dog\") {\n    return(\"Woof!\")\n  } else {\n    return(paste0(\"I don't know what sound a '\",animal,\"' makes...\"))\n  }\n}\n\n\nwhatAnimalSound(\"dog\")\n\n[1] \"Woof!\"\n\nwhatAnimalSound(\"bird\")\n\n[1] \"I don't know what sound a 'bird' makes...\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nNotice that the last statement can be else, but to string together multiple statements you have to use if else.\n\n\n\n\nVectorized if-else: The ifelse() Function\nSometimes we’ll need to create a vector whose values depend on whether or not the values in another vector satisfies some condition. In that case we can use the ifelse() function, which works on a vector of values by repeating the same conditional statement for every value in the vector.\nifelse() takes argument test, the condition to be met, yes, the return value (or vector of values) when test is TRUE, and no, the return values (or vector of values) when test is FALSE.\nFor example, here we convert the values in height to \"short\" or \"tall\" based on whether they are larger than 69 or not:\n\nheight <- c(69, 71, 67, 66, 72, 71, 61, 65, 73, 70, 68, 74)\n\nhtCategory <- ifelse(height > 69, yes = \"tall\", no = \"short\")\n\nhtCategory\n\n [1] \"short\" \"tall\"  \"short\" \"short\" \"tall\"  \"tall\"  \"short\" \"short\" \"tall\" \n[10] \"tall\"  \"short\" \"tall\" \n\n\nThe ifelse function is a very simple way of applying a test to a vector of values. To apply a more complicated function to a vector or to apply a function to multiple rows of a matrix or a dataframe we can use the apply functions which will be discussed later on."
  },
  {
    "objectID": "functions_practicals1_questions.html",
    "href": "functions_practicals1_questions.html",
    "title": "11  Functions 1: Questions",
    "section": "",
    "text": "Question 1\n\n\nLook at the help file for the function mean().\nHow many arguments does the function have?\nWhat types of vectors are accepted?\nWhat is the default setting for dealing with NA values?\n\n\n\n\nQuestion 2\n\n\nUse the function mean() to calculate the mean of the following values:\n\n\n\n\n\n\nNote\n\n\n\nnote the NA and use named argument matching\n\n\n\nc(1, 2, NA, 6)\n\n\n\n\n\nQuestion 3\n\n\nDo Q2 again but rearrange the arguments.\n\n\n\n\nQuestion 4\n\n\nDo Q2 again using positional matching.\n\n\n\n\nQuestion 5\n\n\nDetermine the class of mean() using class().\n\n\n\n\nQuestion 6\n\n\nDetermine the class of mean() using str().\n\n\n\n\nQuestion 7\n\n\nDetermine the class of the value output in Q4 using class().\n\n\n\n\nQuestion 8\n\n\nDetermine the class of the value output in Q4 using str().\n\n\n\n\nQuestion 9\n\n\nUse R as a calculator to calculate the following values:\n17^4=?\n45-2*3=?\n(45-2)*3=?"
  },
  {
    "objectID": "functions_practicals1_questions.html#use-the-operators-and-to-do-the-following",
    "href": "functions_practicals1_questions.html#use-the-operators-and-to-do-the-following",
    "title": "11  Functions 1: Questions",
    "section": "11.2 Use the operators %% and %/% to do the following:",
    "text": "11.2 Use the operators %% and %/% to do the following:\n\nQuestion 10\n\n\nCalculate the remainder after dividing 29,079 into 184,277,809.\n\n\n\n\nQuestion 11\n\n\nHow many times does 29,079 go into 184,277,809 (i.e. what’s the integer divide value)?\n\n\n\n\nQuestion 12\n\n\nDo the last calculation from Q8 in another way, like this:\n\na <- 45\nb <- 2\nc <- 3\nd <- (a - b) * c\n\nNow check what a, b, c, and d are. You can just type the variable name (e.g. a) and hit ‘Control+Enter’ or use the command print(a)."
  },
  {
    "objectID": "functions_practicals1_questions.html#if-else-and-ifelse-and-vectorization",
    "href": "functions_practicals1_questions.html#if-else-and-ifelse-and-vectorization",
    "title": "11  Functions 1: Questions",
    "section": "11.3 if(), else, and ifelse() and Vectorization",
    "text": "11.3 if(), else, and ifelse() and Vectorization\n\nQuestion 13\n\n\nWrite a function called ‘evenOrOdd’ involving if and else that takes an argument x and returns “Even” or “Odd” depending on whether or not x is divisible by 2. (Do not use the ifelse() function).\n\n\n\n\nQuestion 14\n\n\nIs your function ‘evenOrOdd’ vectorized? Check by passing it the vector:\n\nw <- c(3, 6, 6, 4, 7, 9, 11, 6)\n\n\n\n\n\nQuestion 15\n\n\nAnother way to determine if each element of a vector is even or odd is to use the ifelse() function, which serves as a vectorized version if and else. Use ifelse() to obtain “Even” or “Odd” for each element of w."
  },
  {
    "objectID": "functions_practicals1_questions.html#logical-operators-and",
    "href": "functions_practicals1_questions.html#logical-operators-and",
    "title": "11  Functions 1: Questions",
    "section": "11.4 Logical Operators &, |, and !",
    "text": "11.4 Logical Operators &, |, and !\n\nQuestion 16\n\n\nWhat will be the result of the following:\n\n(10 < 20 && 15 < 16) || 9 == 10\n\n\n\n\n\nQuestion 17\n\n\nOne of the following evaluates to TRUE, the other to FALSE. Which is which?\n\n4 < 3 && (5 < 6 || 8 < 9)\n\n\n(4 < 3 && 5 < 6) || 8 < 9\n\n\n\n\n\nQuestion 18\n\n\nThe data set in ‘BPressure.txt’ contains the systolic and diastolic blood pressure readings for 22 patients.\n\nRead the data from BPressure.txt into a data frame called bp using read.table().\nA person’s blood pressure is classified as normal if the systolic level is below 120 and the diastolic level is below 80. Use relational, and logical operations in square brackets [ ] to extract from bp the rows corresponding to patients with normal blood pressures.\nNow use the same strategy to extract the rows corresponding to patients whose blood pressures aren’t normal."
  },
  {
    "objectID": "functions_practicals1_answers.html",
    "href": "functions_practicals1_answers.html",
    "title": "12  Functions 1: Answers",
    "section": "",
    "text": "Warning\n\n\n\nMake sure that you try the exercises yourself first before looking at the answers"
  },
  {
    "objectID": "functions_practicals1_answers.html#function-arguments",
    "href": "functions_practicals1_answers.html#function-arguments",
    "title": "12  Functions 1: Answers",
    "section": "12.1 Function Arguments",
    "text": "12.1 Function Arguments\n\nQuestion 1Answer\n\n\nLook at the help file for the function mean().\nHow many arguments does the function have?\nWhat types of vectors are accepted?\nWhat is the default setting for dealing with NA values?\n\n\nThree arguments (plus further arguments).\nNumerical and logical vectors are accepted.\nThe default setting is to NOT remove NA (missing) values.\n\n\n\n\nQuestion 2Answer\n\n\nUse the function mean() to calculate the mean of the following values:\n\n\n\n\n\n\nNote\n\n\n\nnote the NA and use named argument matching\n\n\n\nc(1, 2, NA, 6)\n\n\n\n\nmean(x = c(1, 2, NA, 6), na.rm = TRUE)\n\n[1] 3\n\n\n\n\n\n\nQuestion 3Answer\n\n\nDo Q2 again but rearrange the arguments.\n\n\n\nmean(na.rm = TRUE, x = c(1, 2, NA, 6))\n\n[1] 3\n\n\n\n\n\n\nQuestion 4Answer\n\n\nDo Q2 again using positional matching.\n\n\n\nmean(c(1, 2, NA, 6), 0, TRUE)\n\n[1] 3\n\n\n\n\n\n\nQuestion 5Answer\n\n\nDetermine the class of mean() using class().\n\n\n\nclass(mean)\n\n[1] \"function\"\n\n\nThe class is function.\n\n\n\n\nQuestion 6Answer\n\n\nDetermine the class of mean() using str().\n\n\n\nstr(mean)\n\nfunction (x, ...)  \n\n\nThe class is function.\n\n\n\n\nQuestion 7Answer\n\n\nDetermine the class of the value output in Q4 using class().\n\n\n\nclass(mean(c(1, 2, NA, 6), 0, TRUE))\n\n[1] \"numeric\"\n\n\nThe class is numeric\n\n\n\n\nQuestion 8Answer\n\n\nDetermine the class of the value output in Q4 using str().\n\n\n\nstr(mean(c(1, 2, NA, 6), 0, TRUE))\n\n num 3\n\n\nThe num means the class is numeric.\n\n\n\n\nQuestion 9Answer\n\n\nUse R as a calculator to calculate the following values:\n17^4=?\n45-2*3=?\n(45-2)*3=?\n\n\n\n17^4\n\n[1] 83521\n\n45 - 2 * 3\n\n[1] 39\n\n(45 - 2) * 3\n\n[1] 129"
  },
  {
    "objectID": "functions_practicals1_answers.html#use-the-operators-and-to-do-the-following",
    "href": "functions_practicals1_answers.html#use-the-operators-and-to-do-the-following",
    "title": "12  Functions 1: Answers",
    "section": "12.2 Use the operators %% and %/% to do the following:",
    "text": "12.2 Use the operators %% and %/% to do the following:\n\nQuestion 10Answer\n\n\nCalculate the remainder after dividing 29,079 into 184,277,809.\n\n\n\n184277809 %% 29079\n\n[1] 4186\n\n\n\n\n\n\nQuestion 11Answer\n\n\nHow many times does 29,079 go into 184,277,809 (i.e. what’s the integer divide value)?\n\n\n\n184277809 %/% 29079\n\n[1] 6337\n\n\n\n\n\n\nQuestion 12Answer\n\n\nDo the last calculation from Q8 in another way, like this:\n\na <- 45\nb <- 2\nc <- 3\nd <- (a - b) * c\n\nNow check what a, b, c, and d are. You can just type the variable name (e.g. a) and hit ‘Control+Enter’ or use the command print(a).\n\n\n\na <- 45\nb <- 2\nc <- 3\nd <- (a - b) * c\n\n\na\n\n[1] 45\n\nb\n\n[1] 2\n\nc\n\n[1] 3\n\nd\n\n[1] 129"
  },
  {
    "objectID": "functions_practicals1_answers.html#if-else-and-ifelse-and-vectorization",
    "href": "functions_practicals1_answers.html#if-else-and-ifelse-and-vectorization",
    "title": "12  Functions 1: Answers",
    "section": "12.3 if(), else, and ifelse() and Vectorization",
    "text": "12.3 if(), else, and ifelse() and Vectorization\n\nQuestion 13Anwser\n\n\nWrite a function called ‘evenOrOdd’ involving if and else that takes an argument x and returns “Even” or “Odd” depending on whether or not x is divisible by 2. (Do not use the ifelse() function).\n\n\n\nevenOrOdd <- function(x) {\n  if(x %% 2 == 0) {\n    return(\"Even\")\n  } else {\n    return(\"Odd\")\n  }\n}\n\n\n\n\n\nQuestion 14Answer\n\n\nIs your function ‘evenOrOdd’ vectorized? Check by passing it the vector:\n\nw <- c(3, 6, 6, 4, 7, 9, 11, 6)\n\n\n\n\nevenOrOdd(w)\n\nError in if (x%%2 == 0) {: the condition has length > 1\n\n\nAn error is given, because x in if(x %% 2 == 0) is longer than 1.\n\n\n\n\nQuestion 15Answer\n\n\nAnother way to determine if each element of a vector is even or odd is to use the ifelse() function, which serves as a vectorized version if and else. Use ifelse() to obtain “Even” or “Odd” for each element of w.\n\n\n\nifelse(w %% 2 == 0, \"Even\", \"Odd\")\n\n[1] \"Odd\"  \"Even\" \"Even\" \"Even\" \"Odd\"  \"Odd\"  \"Odd\"  \"Even\""
  },
  {
    "objectID": "functions_practicals1_answers.html#logical-operators-and",
    "href": "functions_practicals1_answers.html#logical-operators-and",
    "title": "12  Functions 1: Answers",
    "section": "12.4 Logical Operators &, |, and !",
    "text": "12.4 Logical Operators &, |, and !\n\nQuestion 16Answer\n\n\nWhat will be the result of the following:\n\n(10 < 20 && 15 < 16) || 9 == 10\n\n\n\n\n(10 < 20 && 15 < 16) || 9 == 10\n\n[1] TRUE\n\n\nTRUE because the first statement (in parentheses) is TRUE and the second is FALSE.\n\n\n\n\nQuestion 17Answer\n\n\nOne of the following evaluates to TRUE, the other to FALSE. Which is which?\n\n4 < 3 && (5 < 6 || 8 < 9)\n\n\n(4 < 3 && 5 < 6) || 8 < 9\n\n\n\n\n4 < 3 && (5 < 6 || 8 < 9)\n\n\n(4 < 3 && 5 < 6) || 8 < 9\n\nThe first one FALSE because the first statement before && is FALSE. The second one is TRUE because one of the two statements to the left and right of || is TRUE\n\n\n\n\nQuestion 18Answer\n\n\nThe data set in ‘BPressure.txt’ contains the systolic and diastolic blood pressure readings for 22 patients.\n\nRead the data from BPressure.txt into a data frame called bp using read.table().\nA person’s blood pressure is classified as normal if the systolic level is below 120 and the diastolic level is below 80. Use relational, and logical operations in square brackets [ ] to extract from bp the rows corresponding to patients with normal blood pressures.\nNow use the same strategy to extract the rows corresponding to patients whose blood pressures aren’t normal.\n\n\n\n\n\n\n\nbp <- read.table(\"BPressure.txt\", header=TRUE)\n\n\n\n\n\nbp[(bp$Systolic < 120 & bp$Diastolic < 80), ]\n\n   PatientID Systolic Diastolic\n2         SS       96        60\n3         FR      100        70\n8         JI      110        40\n9         MC      119        66\n12        KD      108        54\n13        DS      110        50\n17        SB      118        76\n21        EC      112        62\n\n\n\n\n\n\nbp[!(bp$Systolic < 120 & bp$Diastolic < 80), ]\n\n   PatientID Systolic Diastolic\n1         CK      120        50\n4         CP      120        75\n5         BL      140        90\n6         ES      120        70\n7         CP      165       110\n10        FC      125        76\n11        RW      133        60\n14        JW      130        80\n15        BH      120        65\n16        JW      134        80\n18        NS      122        78\n19        GS      122        70\n20        AB      122        78\n22        HH      122        82"
  },
  {
    "objectID": "functions_intro2.html",
    "href": "functions_intro2.html",
    "title": "Functions 2",
    "section": "",
    "text": "http://stat.ethz.ch/R-manual/R-patched/library/base/html/00Index.html\nhttp://cran.r-project.org/web/packages/available_packages_by_name.html\nhttp://www.bioconductor.org/packages/release/bioc/\nFunctions are expressed as:\nfunction.name(), e.g., t.test() or, an operator, e.g., +\nEasily obtain functions from other R users using install.packages():\ninstall.packages(\"packageName\", lib = \"/directory/to/my custom R library\", repos = \"http://cran.xl-mirror.nl\")\nThe package name must be quoted when installing. Besides installing the package on your PC, you need to load it into your R session before you can use it:\nlibrary(\"packageName\") ## quotes are optional when loading a package"
  },
  {
    "objectID": "functions_scoping.html",
    "href": "functions_scoping.html",
    "title": "13  Function environments and scoping",
    "section": "",
    "text": "The Top-Level (or Global) Environment\nWhen a function is created on the command line, it’s environment is the so-called “Global Environment”:\n\nw <- 2\nf <- function(y) {\n  d <- 3\n  return(d * (w + y))\n}\nenvironment(f)\n\n<environment: R_GlobalEnv>\n\n\nThe function objects() (or ls()), when called from the command line, lists the objects in the Global Environment:\n\nobjects()\n\n[1] \"f\" \"w\"\n\n\n\n\nGlobal and Local Variables\nIn the function f() defined above, the variable w is said to be global to f() and the variable d, because it’s created within f(), is said to be local to f(). Global variables (like w) are visible from within a function, but local variables (like d) aren’t visible from outside the function. In fact, local variables are temporary, and disappear when the function call is completed:\n\nf(y = 1)\nd\n\nYou get an error: Error in eval(expr, envir, enclos) : object ‘d’ not found, indicating that the variable d does not exist in the ‘Global Environment’.\nWhen a global and local variable share the same name, the local variable is used:\n\nw <- 2\nd <- 4\n\nf <- function(y) {\n  d <- 3\n  return(d * (w + y))\n}\n\nf(y = 1)\n\n[1] 9\n\n\nNote also that when an assignment takes place within a function, and the local variable shares its name with an existing global variable, only the local variable is affected:\n\nw <- 2\nd <- 4 # This value of d will remain unchanged.\n\nf <- function(y) {\n  d <- 3 # This doesnt affect the value of d in the global environment\n  return(d * (w + y))\n}\n\nf(y = 1)\n\n[1] 9\n\nd\n\n[1] 4\n\n\n\n\nNested Functions and the Scope Hierarchy\nFor user-defined functions created on the command line, the global variables for that function are those in the global environment. They’re listed by typing ls() (or objects()) on the command line. When a function is created inside another function, its global variables are the local variables of the outer function plus the outer function’s global variables. Regardless of whether a function is created on the command line or inside another function, its local variables are the variables created inside of it plus its formal arguments to which values have been passed\nFor example:\n\nw <- 2 # w is global to f() and therefore also to h()\nf <- function(y) {\n  d <- 3\n  h <- function() {\n    b <- 5 # b is local to h()\n    return(d * (w + y))\n  }\n  return(h())\n}\n\nAbove,\n\nw is a global environment variable to f() and also to h()\ny and d are local variables to f(), but “global” to h()\nb is local to h()\n\nThis scope hierarchy continues when multiple function definitions are nested inside of each other.\nWe can use a print(ls()) statement to see which objects are local to f():\n\nw <- 2 # w is global to f() and therefore also to h()\nf <- function(y) {\n  d <- 3 # y and d are local to f() but global to h()\n  h <- function() {\n    b <- 5 # b is local to h()\n    return(d * (w + y))\n  }\n  print(ls())\n  return(h())\n}\n\nf(y = 2)\n\n[1] \"d\" \"h\" \"y\"\n\n\n[1] 12\n\n\nNote that b is not printed, as it is local to h(), but not to f().\nLikewise we can use a print(environment(h)) statement to view the environment of h():\n\nw <- 2 # w is global to f() and therefore also to h()\nf <- function(y) {\n  d <- 3 # y and d are local to f() but global to h()\n  h <- function() {\n    b <- 5 # b is local to h()\n    return(d * (w + y))\n  }\n  print(environment(h))\n  return(h())\n}\nf(y = 2)\n\n<environment: 0x000001a382fe28b0>\n\n\n[1] 12\n\n\nIn the output above, the environment of h() is referred to by its memory location. The environment of h() is the “container” that contains h() as well as the objects d and y."
  },
  {
    "objectID": "functions_decoration.html",
    "href": "functions_decoration.html",
    "title": "14  Decorating a function with returns, errors, and warnings",
    "section": "",
    "text": "return()     # Terminate a function call and return a value.\nstop()       # Terminate a function call and print an error message.\nwarning()    # Print a warning message (without terminating the \n             # function call).\n\n\nTerminating a Function Call Using if() and return()\nOne way to terminate a function call is with return() which, when encountered, immediately terminates the call and returns a value. For example:\n\nmySign <- function(x) {\n  if(x < 0) return(\"Negative\")\n  if(x > 0) return(\"Positive\")\n  return(\"Zero\")\n}\n\nPassing mySign() the value x = 13 produces the following:\n\nmySign(x = 13)\n\n[1] \"Positive\"\n\n\n(Note that the last line, return(\"Zero\"), was never encountered during the call to my.sign().)\n\n\nTerminating a Function Call and Printing an Error Message Using if() and stop()\nAnother way to terminate a function call is with stop(), which then prints an error message without returning a value. Here’s an example:\n\nmyRatio <- function(x, y) {\n  if(y == 0) stop(\"Cannot divide by 0\")\n  return(x/y)\n}\n\nAn attempt to pass the value 0 for y now results in the following:\n\nmyRatio(x = 3, y = 0)\n\nError in myRatio(x = 3, y = 0): Cannot divide by 0\n\n\n(Note that the last line, return(x/y), was never encountered during the call to myRatio())\n\n\nPrinting a Warning Message Using if() and warning()\nwarning() just prints a warning message to the screen without terminating the function call. Here’s an example:\n\nmyRatio <- function(x, y) {\n  if(y == 0) warning(\"Attempt made to divide by 0\")\n  return(x/y)\n}\n\nNow when we pass the value 0 for y the function call isn’t terminated (the special value Inf is returned), but we get the warning message:\n\nmyRatio(x = 3, y = 0)\n\nWarning in myRatio(x = 3, y = 0): Attempt made to divide by 0\n\n\n[1] Inf\n\n\nBy adding error messages and warnings to you functions it is easier for you and others using your scripts to figure out what went wrong if your script doesn’t return the anticipated answer."
  },
  {
    "objectID": "functions_looping.html",
    "href": "functions_looping.html",
    "title": "15  Looping",
    "section": "",
    "text": "Loops are used to iterate (repeat) an R statement (or set of statements). They’re implemented in three ways, for(), while(), and repeat(), but the most often used are for() loops:\nTwo other commands, break and next, are used, respectively, to terminate a loop’s iterations and to skip ahead to the next iteration:\nHere’s an example in which each of the three loop types, for(), while(), and repeat, are used to perform a simple task, namely printing the numbers 1^2; 2^2; …; 5^2 to the screen:"
  },
  {
    "objectID": "functions_looping.html#for-loops",
    "href": "functions_looping.html#for-loops",
    "title": "15  Looping",
    "section": "15.1 for() Loops",
    "text": "15.1 for() Loops\nfor() loops are used when we know in advance how many iterations the loop should perform. The general form of a for() loop is:\n\nfor(i in sequence) {\n  statement1\n  statement2\n  .\n  .\n  .\n  statementq\n}\n\nwhere sequence is a vector, i (whose name you’re free to change) assumes the values in sequence one after another, each time triggering another iteration of the loop during which statements 1 through q are executed. The statements usually involve the variable i.\nHere’s an example. Suppose we have the data frame describing someone’s coin collection:\n\ncoins <- data.frame(Coin = c(\"penny\", \"quarter\", \"nickel\", \"quarter\", \"dime\", \"penny\"),\n                    Year = c(1943, 1905, 1889, 1960, 1937, 1900),\n                    Mint = c(\"Den\", \"SF\", \"Phil\", \"Den\", \"SF\", \"Den\"),\n                    Condition = c(\"good\", \"fair\", \"excellent\", \"good\", \"poor\", \"good\"),\n                    Value = c(12.00, 55.00, 300.00, 40.00, 18.00, 28.00),\n                    Price = c(15.00, 45.00, 375.00, 25.00, 20.00, 20.00))\ncoins\n\n     Coin Year Mint Condition Value Price\n1   penny 1943  Den      good    12    15\n2 quarter 1905   SF      fair    55    45\n3  nickel 1889 Phil excellent   300   375\n4 quarter 1960  Den      good    40    25\n5    dime 1937   SF      poor    18    20\n6   penny 1900  Den      good    28    20\n\n\nIf we type:\n\ncolMeans(coins)\n\nError in colMeans(coins): 'x' must be numeric\n\n\nwe get an error message because some of the columns are non-numeric. We can compute the means of the numeric columns by looping over the columns, each time checking whether it’s numeric before computing it’s mean:\n\nmeans <- NULL\nfor(i in 1:ncol(coins)) {\n  if (is.numeric(coins[ , i])) {\n    means <- c(means, mean(coins[ , i]))\n  }\n}\n\nThe result is:\n\nmeans\n\n[1] 1922.33333   75.50000   83.33333"
  },
  {
    "objectID": "functions_looping.html#looping-over-list-elements",
    "href": "functions_looping.html#looping-over-list-elements",
    "title": "15  Looping",
    "section": "15.2 Looping Over List Elements",
    "text": "15.2 Looping Over List Elements\nIn the next example, we loop over the elements of a list, printing a list element and recording it’s length during each iteration:\n\nmyList <- list(\n  w = c(4, 4, 5, 5, 6, 6),\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(5, 10, 15),\n  z = c(\"r\", \"s\", \"t\", \"u\", \"v\")\n)\n\nlengths <- NULL\n\nfor(i in myList) {\n  print(i)\n  lengths <- c(lengths, length(i))\n}\n\n[1] 4 4 5 5 6 6\n[1] \"a\" \"b\" \"c\"\n[1]  5 10 15\n[1] \"r\" \"s\" \"t\" \"u\" \"v\"\n\nlengths\n\n[1] 6 3 3 5\n\n\nThese examples are very simple, but looping is a very powerful programming structure for automating analyses, or data processing.\nIn the next chapter we will look at the apply() family of functions, that have been designed for applying functions to a data set in several convenient ways."
  },
  {
    "objectID": "functions_apply.html",
    "href": "functions_apply.html",
    "title": "16  Using apply functions",
    "section": "",
    "text": "The apply functions make it easier to run functions over vectors, matrixes, and data.frames. We will discuss four functions of the apply family that are regularly used apply(), lapply(), sapply() and tapply().\n\nUsing apply on matrices\nThe apply function works by “applying” a specified function to an data object. It requires 3 arguments: the data, a so-called “MARGIN”, and a function. The data can be a vector, data.frame or a matrix. The MARGIN indicates whether you want to apply the function to the rows or the columns of your data, or both. To apply the function to the rows the MARGIN should be 1, to apply it to the columns it should be 2 and to apply it to both it should be c(1,2). The function can be an existing function, such as sum() or mean(), or your own custom function.\nAs an example we will apply the function max() to some data, in this case a matrix.\nFirst we create a matrix of 10 by 10.\n\nmat <- matrix(1:100,nrow=10)\n\nmat\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    1   11   21   31   41   51   61   71   81    91\n [2,]    2   12   22   32   42   52   62   72   82    92\n [3,]    3   13   23   33   43   53   63   73   83    93\n [4,]    4   14   24   34   44   54   64   74   84    94\n [5,]    5   15   25   35   45   55   65   75   85    95\n [6,]    6   16   26   36   46   56   66   76   86    96\n [7,]    7   17   27   37   47   57   67   77   87    97\n [8,]    8   18   28   38   48   58   68   78   88    98\n [9,]    9   19   29   39   49   59   69   79   89    99\n[10,]   10   20   30   40   50   60   70   80   90   100\n\n\nThen we apply our function “max” to the matrix rows, indicated with a 1 (notice that we do not run the function by writing max(), but we just give the name of the function that should be run: max).\n\napply(mat, 1, max)\n\n [1]  91  92  93  94  95  96  97  98  99 100\n\n\nThe result of applying the function max to the rows of the matrix is a vector containing the maximal values for each row.\nWe can also determine the maximal value in each column by using 2 as the MARGIN value.\n\napply(mat, 2, max)\n\n [1]  10  20  30  40  50  60  70  80  90 100\n\n\nAs mentionned before, it is also possible to apply the functions to each element in the matrix by using c(1,2). In that case it doesn’t make sense to determine the maximum value, so lets take the square root.\n\napply(mat, c(1,2), sqrt)\n\n          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8]\n [1,] 1.000000 3.316625 4.582576 5.567764 6.403124 7.141428 7.810250 8.426150\n [2,] 1.414214 3.464102 4.690416 5.656854 6.480741 7.211103 7.874008 8.485281\n [3,] 1.732051 3.605551 4.795832 5.744563 6.557439 7.280110 7.937254 8.544004\n [4,] 2.000000 3.741657 4.898979 5.830952 6.633250 7.348469 8.000000 8.602325\n [5,] 2.236068 3.872983 5.000000 5.916080 6.708204 7.416198 8.062258 8.660254\n [6,] 2.449490 4.000000 5.099020 6.000000 6.782330 7.483315 8.124038 8.717798\n [7,] 2.645751 4.123106 5.196152 6.082763 6.855655 7.549834 8.185353 8.774964\n [8,] 2.828427 4.242641 5.291503 6.164414 6.928203 7.615773 8.246211 8.831761\n [9,] 3.000000 4.358899 5.385165 6.244998 7.000000 7.681146 8.306624 8.888194\n[10,] 3.162278 4.472136 5.477226 6.324555 7.071068 7.745967 8.366600 8.944272\n          [,9]     [,10]\n [1,] 9.000000  9.539392\n [2,] 9.055385  9.591663\n [3,] 9.110434  9.643651\n [4,] 9.165151  9.695360\n [5,] 9.219544  9.746794\n [6,] 9.273618  9.797959\n [7,] 9.327379  9.848858\n [8,] 9.380832  9.899495\n [9,] 9.433981  9.949874\n[10,] 9.486833 10.000000\n\n\nBecause sqrt also works on matrices, it is actually unnecessary to use apply to run it for each element in the matrix. In cases where functions cannot directly be run on a matrix, apply offers a short and readible alternative to writing a nested for loop.\n\n\nUsing lapply on lists to return lists\nThe lapply function is used to run a function on list objects. Let’s assume we have a list of different sized matrices and we would like to know the dimensions of these matrices. We can then run the function “dim” on the list using lapply. lapply only requires a list object and a function as arguments and always returns a list of results.\n\nmylist <- list(matrix(1:16,nrow=4), matrix(1:9,nrow=3),matrix(1:4,nrow=2))\n\nlapply(mylist, dim)\n\n[[1]]\n[1] 4 4\n\n[[2]]\n[1] 3 3\n\n[[3]]\n[1] 2 2\n\n\nBecause dataframes are lists of lists, it is also possible to run lapply on dataframes. In that case lapply will apply the function to the columns of the data.frame object and it returns a list of values.\n\ndf <- data.frame(\"col1\"=c(1,1,1,1), \"col2\"=c(2,2,2,2), \"col3\"=c(3,3,3,3))\n\nlapply(df, sum)\n\n$col1\n[1] 4\n\n$col2\n[1] 8\n\n$col3\n[1] 12\n\n\n\n\nUsing lapply alternative sapply\nsapply is a user-friendly version of lapply. The difference with lapply is that sapply tries to turn the list of results into a more user-friendly format, such as a vector or a matrix.\nFor the first example the results are turned into a matrix.\n\nsapply(mylist, dim)\n\n     [,1] [,2] [,3]\n[1,]    4    3    2\n[2,]    4    3    2\n\n\nFor the second example, the results are turned into a vector.\n\nsapply(df, sum)\n\ncol1 col2 col3 \n   4    8   12 \n\n\nThere is no difference between lapply and sapply in how the data is used, but it gives you more flexibility in how the results are created.\n\n\nUsing tapply on groups of data\ntapply lets you apply a function on groupings of your data. Imagine that you have a dataset in which a grouping factor separates your data into two groups of patients. With tapply you can apply a function to those two groups separately. The only thing tapply requires is the column you would like to apply the function to, the grouping factor and the function you would like to apply.\n\npatients <- data.frame(\"group\"=paste('grp',c(1,1,1,1,1,1,2,2,2,2,2,2),sep='-'), \"outcome\"=rnorm(12))\npatients\n\n   group    outcome\n1  grp-1 -1.4770519\n2  grp-1 -1.1647518\n3  grp-1  0.5826209\n4  grp-1  1.1323839\n5  grp-1 -0.1326188\n6  grp-1  1.1109759\n7  grp-2 -0.7500019\n8  grp-2 -1.5924143\n9  grp-2  0.2815724\n10 grp-2  1.0569330\n11 grp-2 -1.0680512\n12 grp-2 -1.5892831\n\ntapply(patients$outcome, patients$group, mean)\n\n       grp-1        grp-2 \n 0.008593042 -0.610207533 \n\n\nIt is also possible to use multiple factors in a list to create groups, which returns a matrix.\n\npatients <- data.frame(\"group\"=paste('grp',c(1,1,1,1,1,1,2,2,2,2,2,2),sep='-'),\n                       \"serotype\"=c(\"A\",\"B\",\"A\",\"B\",\"A\",\"B\",\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"),\n                       \"outcome\"=rnorm(12))\n\ntapply(patients$outcome, list(patients$group, patients$serotype), mean)\n\n               A          B\ngrp-1 -0.5409469 -0.8562062\ngrp-2  0.1801366  0.7186676\n\n\nThese are some (trivial) examples of how you can use the apply family of functions to quickly apply a function to your data. It is possible to do the same thing by using for loops, but apply functions are generally faster to write and read. In some cases using apply to run your function can also increase the speed of your code. More on increasing the speed of your code will follow in later lectures."
  },
  {
    "objectID": "functions_practicals2_questions.html",
    "href": "functions_practicals2_questions.html",
    "title": "17  Functions 2: Questions",
    "section": "",
    "text": "Question 1\n\n\nFor each of the following sets of commands, give the value that will be returned by the last command. Try to answer without using R.\n\n\n\n\nw <- 5\nf <- function(y) {\n  return(w + y)\n}\nf(y = 2)\n\n\n\n\n\nw <- 5\nf <- function(y) {\n  w <- 4\n  return(w + y)\n}\nf(y = 2)\n\n\n\n\n\nQuestion 2\n\n\nAmong the variables w, d, and y, which are global to f() and which are local? What is the value of z when executing f(w)\n\nw <- 2\nf <- function(y) {\n  d <- 3\n  h <- function(z) {\n    return(z + d)\n  }\n  return(y * h(y))\n}\n\n\n\n\n\nQuestion 3\n\n\nDo the following in R:\n\nTry:\n\n\nmyFun1 <- function(a) {\n  b <- 3\n  myFun2(a)\n}\n\nmyFun2 <- function(y) {\n  return(y + a + b)\n}\n\nmyFun1(10)\n\nWhat happens?\n\nNow try:\n\n\na <- 1\nb <- 2\nmyFun1(10)\n\nWhat happens?"
  },
  {
    "objectID": "functions_practicals2_questions.html#decorating-a-function-with-returns-errors-and-warnings",
    "href": "functions_practicals2_questions.html#decorating-a-function-with-returns-errors-and-warnings",
    "title": "17  Functions 2: Questions",
    "section": "17.2 Decorating a function with returns, errors, and warnings",
    "text": "17.2 Decorating a function with returns, errors, and warnings\nThe functions warning() and stop() are used to print a warning message and to stop the execution of the function call and print an error message. For example:\n\nnoNegMean <- function(x) {\n  if(all(x < 0)) {\n    stop(\"All values in x are negative\")\n  }\n  \n  if(any(x < 0)) {\n    x[x < 0] <- 0\n    warning(\"Negative values in x replaced by zero\")\n  }\n  \n  return(mean(x))\n}\n\n\nQuestion 1\n\n\nCopy the above code and then pass noNegMean() a vector containing some negative and some positive values. What happens?\n\n\n\n\nQuestion 2\n\n\nWhat happens when you pass noNegMean() a vector containing all negative values?\n\n\n\n\nQuestion 3\n\n\nWrite a function ratio() that takes two arguments, x and y, and attempts to compute the ratio x/y.\nIf both x == 0 & y == 0, the function should stop and print an error message about dividing 0 by 0.\nIf y == 0 (but not x), the function should print a warning message about dividing by 0, and then return x/y (which will be Inf).\nIn all other cases, it should return x/y.\nTest your ratio() function first using two nonzero values for x and y, then using a nonzero x but y = 0, and finally using x = 0 and y = 0."
  },
  {
    "objectID": "functions_practicals2_questions.html#looping-using-for-loops-and-the-apply-functions",
    "href": "functions_practicals2_questions.html#looping-using-for-loops-and-the-apply-functions",
    "title": "17  Functions 2: Questions",
    "section": "17.3 Looping using for() loops and the apply functions",
    "text": "17.3 Looping using for() loops and the apply functions\n\nQuestion 1\n\n\nCopy this is a function to determine if a number is a prime number:\n\nisPrime <- function(num){\n  if (num == 2) {\n    return(TRUE)\n  }\n  if(num > 1) {\n    for(i in 2:(num-1)) {\n      if ((num %% i) == 0) {\n        return(FALSE)\n      }\n    }\n  } else {\n    return(FALSE)\n  }\n  \n  return(TRUE)\n}\n\nCopy this matrix for which we would like to check if a number is a prime number:\n\nmat <- matrix(1:100, nrow=10)\n\nUse the apply() function to calculate the prime number for each number in the matrix.\nWhat numbers from 1 until 100 are prime numbers?\n\n\n\n\nQuestion 2\n\n\nCopy the following command to create a list containing two generations of the famous Kennedy family:\n\nKennedys <- list(\n    JosephJr = character(0),\n    John = c(\"Caroline\", \"JohnJr\", \"Patrick\"),\n    Rosemary = character(0),\n    Kathleen = character(0),\n    Eunice = c(\"RobertIII\", \"Maria\", \"Timothy\", \"Mark\", \"Anthony\"),\n    Patricia = c(\"Christopher\", \"Sydney\", \"Victoria\", \"Robin\"),\n    Robert = c(\"Kathleen\", \"JosephII\", \"RobertJr\", \"David\", \n               \"MaryC\", \"Michael\", \"MaryK\", \"Christopher\", \n               \"Matthew\", \"Douglas\", \"Rory\"),\n    Jean = c(\"Stephen\", \"William\", \"Amanda\", \"Kym\"),\n    Edward = c(\"Kara\", \"EdwardJr\", \"Patrick\")\n)\n\nUse a for() loop to loop over the list of the first generation of Kennedys, keeping track of how many children each one has in a vector.\n\n\n\n\nQuestion 3\n\n\nNow, using the lapply() function, loop over the list of the first generation of Kennedys and keep track of how many children each Kennedy has. What is the class of the output?\n\n\n\n\nQuestion 3\n\n\nAnswer Q2 again using the sapply() function. What is the class of the output?\n\n\n\n\nQuestion 4\n\n\nLoad the “diamonds” dataset from the ggplot2 package by running library(gglot2) and calculate the average price of diamonds by color and clarity using the tapply() function."
  },
  {
    "objectID": "functions_practicals2_answers.html",
    "href": "functions_practicals2_answers.html",
    "title": "18  Functions 2: Answers",
    "section": "",
    "text": "Warning\n\n\n\nMake sure that you try the exercises yourself first before looking at the answers"
  },
  {
    "objectID": "functions_practicals2_answers.html#function-environment-and-scoping",
    "href": "functions_practicals2_answers.html#function-environment-and-scoping",
    "title": "18  Functions 2: Answers",
    "section": "18.1 Function environment and scoping",
    "text": "18.1 Function environment and scoping\n\nQuestion 1Answer\n\n\nFor each of the following sets of commands, give the value that will be returned by the last command. Try to answer without using R.\n\n\n\n\nw <- 5\nf <- function(y) {\n  return(w + y)\n}\nf(y = 2)\n\n\n\n\n\nw <- 5\nf <- function(y) {\n  w <- 4\n  return(w + y)\n}\nf(y = 2)\n\n\n\n\nThis will return 7 because w is 5 and we are evaluating the function at y = 2\nThis will return 6 because w is reassigned as 4 inside the function and we are evaluating the function at y = 2.\n\n\n\n\n\nQuestion 2Answer\n\n\nAmong the variables w, d, and y, which are global to f() and which are local? What is the value of z when executing f(w)\n\nw <- 2\nf <- function(y) {\n  d <- 3\n  h <- function(z) {\n    return(z + d)\n  }\n  return(y * h(y))\n}\n\n\n\nThe object w is global to f() while d and y are local to f().\nz is 2, because it takes the value of y when executing h(y) in function f(), which takes the value of global variable w when executing f(w)\n\n\n\n\nQuestion 3Answer\n\n\nDo the following in R:\n\nTry:\n\n\nmyFun1 <- function(a) {\n  b <- 3\n  myFun2(a)\n}\n\nmyFun2 <- function(y) {\n  return(y + a + b)\n}\n\nmyFun1(10)\n\nWhat happens?\n\nNow try:\n\n\na <- 1\nb <- 2\nmyFun1(10)\n\nWhat happens?\n\n\n\nWe get an error message because a and b are local to myFun1 so the function myFun2 can’t find them in the global environment.\nWe get get the value 13 because the values a and b are global so myFun2 can find them and use them in its commands."
  },
  {
    "objectID": "functions_practicals2_answers.html#decorating-a-function-with-returns-errors-and-warnings",
    "href": "functions_practicals2_answers.html#decorating-a-function-with-returns-errors-and-warnings",
    "title": "18  Functions 2: Answers",
    "section": "18.2 Decorating a function with returns, errors, and warnings",
    "text": "18.2 Decorating a function with returns, errors, and warnings\nThe functions warning() and stop() are used to print a warning message and to stop the execution of the function call and print an error message. For example:\n\nnoNegMean <- function(x) {\n  if(all(x < 0)) {\n    stop(\"All values in x are negative\")\n  }\n  \n  if(any(x < 0)) {\n    x[x < 0] <- 0\n    warning(\"Negative values in x replaced by zero\")\n  }\n  \n  return(mean(x))\n}\n\n\nQuestion 1Answer\n\n\nCopy the above code and then pass noNegMean() a vector containing some negative and some positive values. What happens?\n\n\n\nnoNegMean(c(-1,0,1))\n\nWarning in noNegMean(c(-1, 0, 1)): Negative values in x replaced by zero\n\n\n[1] 0.3333333\n\n\nWe get the warning message and it returned 0.3333, which is the average of c(0, 0, 1).\n\n\n\n\nQuestion 2Answer\n\n\nWhat happens when you pass noNegMean() a vector containing all negative values?\n\n\n\nnoNegMean(c(-1,-1,-1))\n\nError in noNegMean(c(-1, -1, -1)): All values in x are negative\n\n\nWe get the error message and nothing is returned.\n\n\n\n\nQuestion 3Answer\n\n\nWrite a function ratio() that takes two arguments, x and y, and attempts to compute the ratio x/y.\nIf both x == 0 & y == 0, the function should stop and print an error message about dividing 0 by 0.\nIf y == 0 (but not x), the function should print a warning message about dividing by 0, and then return x/y (which will be Inf).\nIn all other cases, it should return x/y.\nTest your ratio() function first using two nonzero values for x and y, then using a nonzero x but y = 0, and finally using x = 0 and y = 0.\n\n\n\nratio <- function(x,y) {\n  if(x == 0 & y == 0) {\n    stop(\"Cannot divide zero by zero.\")\n  }\n\n  if(y == 0) {\n    warning(\"Cannot divide by zero.\")\n  }\n\n  ratio <- x/y\n  return(ratio)\n}\n\n\nratio(2,3)\n\n[1] 0.6666667\n\nratio(0,0)\n\nError in ratio(0, 0): Cannot divide zero by zero.\n\nratio(1,0)\n\nWarning in ratio(1, 0): Cannot divide by zero.\n\n\n[1] Inf"
  },
  {
    "objectID": "functions_practicals2_answers.html#looping-using-for-loops-and-the-apply-functions",
    "href": "functions_practicals2_answers.html#looping-using-for-loops-and-the-apply-functions",
    "title": "18  Functions 2: Answers",
    "section": "18.3 looping using for() loops and the apply functions",
    "text": "18.3 looping using for() loops and the apply functions\n\nQuestion 1Answer\n\n\nCopy this is a function to determine if a number is a prime number:\n\nisPrime <- function(num){\n  if (num == 2) {\n    return(TRUE)\n  }\n  if(num > 1) {\n    for(i in 2:(num-1)) {\n      if ((num %% i) == 0) {\n        return(FALSE)\n      }\n    }\n  } else {\n    return(FALSE)\n  }\n  \n  return(TRUE)\n}\n\nCopy this matrix for which we would like to check if a number is a prime number:\n\nmat <- matrix(1:100, nrow=10)\n\nUse the apply() function to calculate the prime number for each number in the matrix.\nWhat numbers from 1 until 100 are prime numbers?\n\n\n\napply(mat, c(1,2), isPrime)\n\n       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10]\n [1,] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n [2,]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [3,]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n [4,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [5,]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [6,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [7,]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n [8,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [9,] FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n[10,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\nmat[apply(mat, c(1,2), isPrime)]\n\n [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97\n\n\n\n\n\n\nQuestion 2Answer\n\n\nCopy the following command to create a list containing two generations of the famous Kennedy family:\n\nKennedys <- list(\n    JosephJr = character(0),\n    John = c(\"Caroline\", \"JohnJr\", \"Patrick\"),\n    Rosemary = character(0),\n    Kathleen = character(0),\n    Eunice = c(\"RobertIII\", \"Maria\", \"Timothy\", \"Mark\", \"Anthony\"),\n    Patricia = c(\"Christopher\", \"Sydney\", \"Victoria\", \"Robin\"),\n    Robert = c(\"Kathleen\", \"JosephII\", \"RobertJr\", \"David\", \n               \"MaryC\", \"Michael\", \"MaryK\", \"Christopher\", \n               \"Matthew\", \"Douglas\", \"Rory\"),\n    Jean = c(\"Stephen\", \"William\", \"Amanda\", \"Kym\"),\n    Edward = c(\"Kara\", \"EdwardJr\", \"Patrick\")\n)\n\nUse a for() loop to loop over the list of the first generation of Kennedys, keeping track of how many children each one has in a vector.\n\n\n\nchildren <- NULL\nfor(i in Kennedys){\n  children <- c(children, length(i))\n}\nchildren\n\n[1]  0  3  0  0  5  4 11  4  3\n\n\n\n\n\n\nQuestion 3Answer\n\n\nNow, using the lapply() function, loop over the list of the first generation of Kennedys and keep track of how many children each Kennedy has. What is the class of the output?\n\n\n\nresult <- lapply(Kennedys, length)\nresult\n\n$JosephJr\n[1] 0\n\n$John\n[1] 3\n\n$Rosemary\n[1] 0\n\n$Kathleen\n[1] 0\n\n$Eunice\n[1] 5\n\n$Patricia\n[1] 4\n\n$Robert\n[1] 11\n\n$Jean\n[1] 4\n\n$Edward\n[1] 3\n\nclass(result)\n\n[1] \"list\"\n\n\n\n\n\n\nQuestion 4Answer\n\n\nAnswer Q2 again using the sapply() function. What is the class of the output?\n\n\n\nresult <- sapply(Kennedys, length)\nresult\n\nJosephJr     John Rosemary Kathleen   Eunice Patricia   Robert     Jean \n       0        3        0        0        5        4       11        4 \n  Edward \n       3 \n\nclass(result)\n\n[1] \"integer\"\n\n\n\n\n\n\nQuestion 5Answer\n\n\nLoad the “diamonds” dataset from the ggplot2 package by running library(gglot2) and calculate the average price of diamonds by color and clarity using the tapply() function.\n\n\n\nlibrary(ggplot2)\ntapply(diamonds$price, list(diamonds$color, diamonds$clarity), mean)\n\n        I1      SI2      SI1      VS2      VS1     VVS2     VVS1       IF\nD 3863.024 3931.101 2976.146 2587.226 3030.159 3351.128 2947.913 8307.370\nE 3488.422 4173.826 3161.838 2750.942 2856.294 2499.674 2219.820 3668.506\nF 3342.182 4472.625 3714.226 3756.795 3796.718 3475.513 2804.277 2750.836\nG 3545.693 5021.684 3774.787 4416.256 4131.362 3845.283 2866.821 2558.034\nH 4453.414 6099.895 5032.415 4722.414 3780.689 2649.067 1845.658 2287.870\nI 4302.185 7002.649 5355.020 5690.506 4633.184 2968.233 2034.862 1994.937\nJ 5254.060 6520.958 5186.048 5311.059 4884.461 5142.397 4034.176 3363.882"
  }
]